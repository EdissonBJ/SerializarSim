<html lang='en'><head><link href='prism/prism.css' rel='stylesheet' /></head><body><script src='prism/prism.js'></script><body><div><pre><code class='language-html'>&lt;html dir="ltr" lang="es"&gt;<br/>
 &lt;head&gt;<br/>
  &lt;meta charset="utf-8"&gt;<br/>
  &lt;meta name="color-scheme" content="light dark"&gt;<br/>
  &lt;meta name="theme-color" content="#fff"&gt;<br/>
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0,<br/>
                                 maximum-scale=1.0, user-scalable=no"&gt;<br/>
  &lt;title&gt;10.203.114.11&lt;/title&gt;<br/>
  &lt;style&gt;/* Copyright 2017 The Chromium Authors<br/>
 * Use of this source code is governed by a BSD-style license that can be<br/>
 * found in the LICENSE file. */<br/>
<br/>
a {<br/>
  color: var(--link-color);<br/>
}<br/>
<br/>
body {<br/>
  --background-color: #fff;<br/>
  --error-code-color: var(--google-gray-700);<br/>
  --google-blue-50: rgb(232, 240, 254);<br/>
  --google-blue-100: rgb(210, 227, 252);<br/>
  --google-blue-300: rgb(138, 180, 248);<br/>
  --google-blue-600: rgb(26, 115, 232);<br/>
  --google-blue-700: rgb(25, 103, 210);<br/>
  --google-gray-100: rgb(241, 243, 244);<br/>
  --google-gray-300: rgb(218, 220, 224);<br/>
  --google-gray-500: rgb(154, 160, 166);<br/>
  --google-gray-50: rgb(248, 249, 250);<br/>
  --google-gray-600: rgb(128, 134, 139);<br/>
  --google-gray-700: rgb(95, 99, 104);<br/>
  --google-gray-800: rgb(60, 64, 67);<br/>
  --google-gray-900: rgb(32, 33, 36);<br/>
  --heading-color: var(--google-gray-900);<br/>
  --link-color: rgb(88, 88, 88);<br/>
  --primary-button-fill-color-active: var(--google-blue-700);<br/>
  --primary-button-fill-color: var(--google-blue-600);<br/>
  --primary-button-text-color: #fff;<br/>
  --quiet-background-color: rgb(247, 247, 247);<br/>
  --secondary-button-border-color: var(--google-gray-500);<br/>
  --secondary-button-fill-color: #fff;<br/>
  --secondary-button-hover-border-color: var(--google-gray-600);<br/>
  --secondary-button-hover-fill-color: var(--google-gray-50);<br/>
  --secondary-button-text-color: var(--google-gray-700);<br/>
  --small-link-color: var(--google-gray-700);<br/>
  --text-color: var(--google-gray-700);<br/>
  background: var(--background-color);<br/>
  color: var(--text-color);<br/>
  word-wrap: break-word;<br/>
}<br/>
<br/>
.nav-wrapper .secondary-button {<br/>
  background: var(--secondary-button-fill-color);<br/>
  border: 1px solid var(--secondary-button-border-color);<br/>
  color: var(--secondary-button-text-color);<br/>
  float: none;<br/>
  margin: 0;<br/>
  padding: 8px 16px;<br/>
}<br/>
<br/>
.hidden {<br/>
  display: none;<br/>
}<br/>
<br/>
html {<br/>
  -webkit-text-size-adjust: 100%;<br/>
  font-size: 125%;<br/>
}<br/>
<br/>
.icon {<br/>
  background-repeat: no-repeat;<br/>
  background-size: 100%;<br/>
}<br/>
<br/>
@media (prefers-color-scheme: dark) {<br/>
  body {<br/>
    --background-color: var(--google-gray-900);<br/>
    --error-code-color: var(--google-gray-500);<br/>
    --heading-color: var(--google-gray-500);<br/>
    --link-color: var(--google-blue-300);<br/>
    --primary-button-fill-color-active: rgb(129, 162, 208);<br/>
    --primary-button-fill-color: var(--google-blue-300);<br/>
    --primary-button-text-color: var(--google-gray-900);<br/>
    --quiet-background-color: var(--background-color);<br/>
    --secondary-button-border-color: var(--google-gray-700);<br/>
    --secondary-button-fill-color: var(--google-gray-900);<br/>
    --secondary-button-hover-fill-color: rgb(48, 51, 57);<br/>
    --secondary-button-text-color: var(--google-blue-300);<br/>
    --small-link-color: var(--google-blue-300);<br/>
    --text-color: var(--google-gray-500);<br/>
  }<br/>
}<br/>
&lt;/style&gt;<br/>
  &lt;style&gt;/* Copyright 2014 The Chromium Authors<br/>
   Use of this source code is governed by a BSD-style license that can be<br/>
   found in the LICENSE file. */<br/>
<br/>
button {<br/>
  border: 0;<br/>
  border-radius: 20px;<br/>
  box-sizing: border-box;<br/>
  color: var(--primary-button-text-color);<br/>
  cursor: pointer;<br/>
  float: right;<br/>
  font-size: .875em;<br/>
  margin: 0;<br/>
  padding: 8px 16px;<br/>
  transition: box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1);<br/>
  user-select: none;<br/>
}<br/>
<br/>
[dir='rtl'] button {<br/>
  float: left;<br/>
}<br/>
<br/>
.bad-clock button,<br/>
.captive-portal button,<br/>
.https-only button,<br/>
.insecure-form button,<br/>
.lookalike-url button,<br/>
.main-frame-blocked button,<br/>
.neterror button,<br/>
.pdf button,<br/>
.ssl button,<br/>
.enterprise-block button,<br/>
.enterprise-warn button,<br/>
.managed-profile-required button,<br/>
.safe-browsing-billing button,<br/>
.supervised-user-verify button,<br/>
.supervised-user-verify-subframe button {<br/>
  background: var(--primary-button-fill-color);<br/>
}<br/>
<br/>
button:active {<br/>
  background: var(--primary-button-fill-color-active);<br/>
  outline: 0;<br/>
}<br/>
<br/>
#debugging {<br/>
  display: inline;<br/>
  overflow: auto;<br/>
}<br/>
<br/>
.debugging-content {<br/>
  line-height: 1em;<br/>
  margin-bottom: 0;<br/>
  margin-top: 1em;<br/>
}<br/>
<br/>
.debugging-content-fixed-width {<br/>
  display: block;<br/>
  font-family: monospace;<br/>
  font-size: 1.2em;<br/>
  margin-top: 0.5em;<br/>
}<br/>
<br/>
.debugging-title {<br/>
  font-weight: bold;<br/>
}<br/>
<br/>
#details {<br/>
  margin: 0 0 50px;<br/>
}<br/>
<br/>
#details p:not(:first-of-type) {<br/>
  margin-top: 20px;<br/>
}<br/>
<br/>
.secondary-button:active {<br/>
  border-color: white;<br/>
  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3),<br/>
      0 2px 6px 2px rgba(60, 64, 67, .15);<br/>
}<br/>
<br/>
.secondary-button:hover {<br/>
  background: var(--secondary-button-hover-fill-color);<br/>
  border-color: var(--secondary-button-hover-border-color);<br/>
  text-decoration: none;<br/>
}<br/>
<br/>
.error-code {<br/>
  color: var(--error-code-color);<br/>
  font-size: .8em;<br/>
  margin-top: 12px;<br/>
  text-transform: uppercase;<br/>
}<br/>
<br/>
#error-debugging-info {<br/>
  font-size: 0.8em;<br/>
}<br/>
<br/>
h1 {<br/>
  color: var(--heading-color);<br/>
  font-size: 1.6em;<br/>
  font-weight: normal;<br/>
  line-height: 1.25em;<br/>
  margin-bottom: 16px;<br/>
}<br/>
<br/>
h2 {<br/>
  font-size: 1.2em;<br/>
  font-weight: normal;<br/>
}<br/>
<br/>
.icon {<br/>
  height: 72px;<br/>
  margin: 0 0 40px;<br/>
  width: 72px;<br/>
}<br/>
<br/>
input[type=checkbox] {<br/>
  opacity: 0;<br/>
}<br/>
<br/>
input[type=checkbox]:focus ~ .checkbox::after {<br/>
  outline: -webkit-focus-ring-color auto 5px;<br/>
}<br/>
<br/>
.interstitial-wrapper {<br/>
  box-sizing: border-box;<br/>
  font-size: 1em;<br/>
  line-height: 1.6em;<br/>
  margin: 14vh auto 0;<br/>
  max-width: 600px;<br/>
  width: 100%;<br/>
}<br/>
<br/>
#main-message &gt; p {<br/>
  display: inline;<br/>
}<br/>
<br/>
#extended-reporting-opt-in {<br/>
  font-size: .875em;<br/>
  margin-top: 32px;<br/>
}<br/>
<br/>
#extended-reporting-opt-in label {<br/>
  display: grid;<br/>
  grid-template-columns: 1.8em 1fr;<br/>
  position: relative;<br/>
}<br/>
<br/>
#enhanced-protection-message {<br/>
  border-radius: 20px;<br/>
  font-size: 1em;<br/>
  margin-top: 32px;<br/>
  padding: 10px 5px;<br/>
}<br/>
<br/>
#enhanced-protection-message a {<br/>
  color: var(--google-red-10);<br/>
}<br/>
<br/>
#enhanced-protection-message label {<br/>
  display: grid;<br/>
  grid-template-columns: 2.5em 1fr;<br/>
  position: relative;<br/>
}<br/>
<br/>
#enhanced-protection-message div {<br/>
  margin: 0.5em;<br/>
}<br/>
<br/>
#enhanced-protection-message .icon {<br/>
  height: 1.5em;<br/>
  vertical-align: middle;<br/>
  width: 1.5em;<br/>
}<br/>
<br/>
.nav-wrapper {<br/>
  margin-top: 51px;<br/>
}<br/>
<br/>
.nav-wrapper::after {<br/>
  clear: both;<br/>
  content: '';<br/>
  display: table;<br/>
  width: 100%;<br/>
}<br/>
<br/>
.small-link {<br/>
  color: var(--small-link-color);<br/>
  font-size: .875em;<br/>
}<br/>
<br/>
.checkboxes {<br/>
  flex: 0 0 24px;<br/>
}<br/>
<br/>
.checkbox {<br/>
  --padding: .9em;<br/>
  background: transparent;<br/>
  display: block;<br/>
  height: 1em;<br/>
  left: -1em;<br/>
  padding-inline-start: var(--padding);<br/>
  position: absolute;<br/>
  right: 0;<br/>
  top: -.5em;<br/>
  width: 1em;<br/>
}<br/>
<br/>
.checkbox::after {<br/>
  border: 1px solid white;<br/>
  border-radius: 2px;<br/>
  content: '';<br/>
  height: 1em;<br/>
  left: var(--padding);<br/>
  position: absolute;<br/>
  top: var(--padding);<br/>
  width: 1em;<br/>
}<br/>
<br/>
.checkbox::before {<br/>
  background: transparent;<br/>
  border: 2px solid white;<br/>
  border-inline-end-width: 0;<br/>
  border-top-width: 0;<br/>
  content: '';<br/>
  height: .2em;<br/>
  left: calc(.3em + var(--padding));<br/>
  opacity: 0;<br/>
  position: absolute;<br/>
  top: calc(.3em  + var(--padding));<br/>
  transform: rotate(-45deg);<br/>
  width: .5em;<br/>
}<br/>
<br/>
input[type=checkbox]:checked ~ .checkbox::before {<br/>
  opacity: 1;<br/>
}<br/>
<br/>
#recurrent-error-message {<br/>
  background: #ededed;<br/>
  border-radius: 4px;<br/>
  margin-bottom: 16px;<br/>
  margin-top: 12px;<br/>
  padding: 12px 16px;<br/>
}<br/>
<br/>
.showing-recurrent-error-message #extended-reporting-opt-in {<br/>
  margin-top: 16px;<br/>
}<br/>
<br/>
.showing-recurrent-error-message #enhanced-protection-message {<br/>
  margin-top: 16px;<br/>
}<br/>
<br/>
@media (max-width: 700px) {<br/>
  .interstitial-wrapper {<br/>
    padding: 0 10%;<br/>
  }<br/>
<br/>
  #error-debugging-info {<br/>
    overflow: auto;<br/>
  }<br/>
}<br/>
<br/>
@media (max-width: 420px) {<br/>
  button,<br/>
  [dir='rtl'] button,<br/>
  .small-link {<br/>
    float: none;<br/>
    font-size: .825em;<br/>
    font-weight: 500;<br/>
    margin: 0;<br/>
    width: 100%;<br/>
  }<br/>
<br/>
  button {<br/>
    padding: 16px 24px;<br/>
  }<br/>
<br/>
  #details {<br/>
    margin: 20px 0 20px 0;<br/>
  }<br/>
<br/>
  #details p:not(:first-of-type) {<br/>
    margin-top: 10px;<br/>
  }<br/>
<br/>
  .secondary-button:not(.hidden) {<br/>
    display: block;<br/>
    margin-top: 20px;<br/>
    text-align: center;<br/>
    width: 100%;<br/>
  }<br/>
<br/>
  .interstitial-wrapper {<br/>
    padding: 0 5%;<br/>
  }<br/>
<br/>
  #extended-reporting-opt-in {<br/>
    margin-top: 24px;<br/>
  }<br/>
<br/>
  #enhanced-protection-message {<br/>
    margin-top: 24px;<br/>
  }<br/>
<br/>
  .nav-wrapper {<br/>
    margin-top: 30px;<br/>
  }<br/>
}<br/>
<br/>
/**<br/>
 * Mobile specific styling.<br/>
 * Navigation buttons are anchored to the bottom of the screen.<br/>
 * Details message replaces the top content in its own scrollable area.<br/>
 */<br/>
<br/>
@media (max-width: 420px) {<br/>
  .nav-wrapper .secondary-button {<br/>
    border: 0;<br/>
    margin: 16px 0 0;<br/>
    margin-inline-end: 0;<br/>
    padding-bottom: 16px;<br/>
    padding-top: 16px;<br/>
  }<br/>
}<br/>
<br/>
/* Fixed nav. */<br/>
@media (min-width: 240px) and (max-width: 420px) and<br/>
       (min-height: 401px),<br/>
       (min-width: 421px) and (min-height: 240px) and<br/>
       (max-height: 560px) {<br/>
  body .nav-wrapper {<br/>
    background: var(--background-color);<br/>
    bottom: 0;<br/>
    box-shadow: 0 -12px 24px var(--background-color);<br/>
    left: 0;<br/>
    margin: 0 auto;<br/>
    max-width: 736px;<br/>
    padding-inline-end: 24px;<br/>
    padding-inline-start: 24px;<br/>
    position: fixed;<br/>
    right: 0;<br/>
    width: 100%;<br/>
    z-index: 2;<br/>
  }<br/>
<br/>
  .interstitial-wrapper {<br/>
    max-width: 736px;<br/>
  }<br/>
<br/>
  #details,<br/>
  #main-content {<br/>
    padding-bottom: 40px;<br/>
  }<br/>
<br/>
  #details {<br/>
    padding-top: 5.5vh;<br/>
  }<br/>
<br/>
  button.small-link {<br/>
    color: var(--google-blue-600);<br/>
  }<br/>
}<br/>
<br/>
@media (max-width: 420px) and (orientation: portrait),<br/>
       (max-height: 560px) {<br/>
  body {<br/>
    margin: 0 auto;<br/>
  }<br/>
<br/>
  button,<br/>
  [dir='rtl'] button,<br/>
  button.small-link,<br/>
  .nav-wrapper .secondary-button {<br/>
    font-family: Roboto-Regular,Helvetica;<br/>
    font-size: .933em;<br/>
    margin: 6px 0;<br/>
    transform: translatez(0);<br/>
  }<br/>
<br/>
  .nav-wrapper {<br/>
    box-sizing: border-box;<br/>
    padding-bottom: 8px;<br/>
    width: 100%;<br/>
  }<br/>
<br/>
  #details {<br/>
    box-sizing: border-box;<br/>
    height: auto;<br/>
    margin: 0;<br/>
    opacity: 1;<br/>
    transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);<br/>
  }<br/>
<br/>
  #details.hidden,<br/>
  #main-content.hidden {<br/>
    height: 0;<br/>
    opacity: 0;<br/>
    overflow: hidden;<br/>
    padding-bottom: 0;<br/>
    transition: none;<br/>
  }<br/>
<br/>
  h1 {<br/>
    font-size: 1.5em;<br/>
    margin-bottom: 8px;<br/>
  }<br/>
<br/>
  .icon {<br/>
    margin-bottom: 5.69vh;<br/>
  }<br/>
<br/>
  .interstitial-wrapper {<br/>
    box-sizing: border-box;<br/>
    margin: 7vh auto 12px;<br/>
    padding: 0 24px;<br/>
    position: relative;<br/>
  }<br/>
<br/>
  .interstitial-wrapper p {<br/>
    font-size: .95em;<br/>
    line-height: 1.61em;<br/>
    margin-top: 8px;<br/>
  }<br/>
<br/>
  #main-content {<br/>
    margin: 0;<br/>
    transition: opacity 100ms cubic-bezier(0.4, 0, 0.2, 1);<br/>
  }<br/>
<br/>
  .small-link {<br/>
    border: 0;<br/>
  }<br/>
<br/>
  .suggested-left &gt; #control-buttons,<br/>
  .suggested-right &gt; #control-buttons {<br/>
    float: none;<br/>
    margin: 0;<br/>
  }<br/>
}<br/>
<br/>
@media (min-width: 421px) and (min-height: 500px) and (max-height: 560px) {<br/>
  .interstitial-wrapper {<br/>
    margin-top: 10vh;<br/>
  }<br/>
}<br/>
<br/>
@media (min-height: 400px) and (orientation:portrait) {<br/>
  .interstitial-wrapper {<br/>
    margin-bottom: 145px;<br/>
  }<br/>
}<br/>
<br/>
@media (min-height: 299px) {<br/>
  .nav-wrapper {<br/>
    padding-bottom: 16px;<br/>
  }<br/>
}<br/>
<br/>
@media (max-height: 560px) and (min-height: 240px) and (orientation:landscape) {<br/>
  .extended-reporting-has-checkbox #details {<br/>
    padding-bottom: 80px;<br/>
  }<br/>
}<br/>
<br/>
@media (min-height: 500px) and (max-height: 650px) and (max-width: 414px) and<br/>
       (orientation: portrait) {<br/>
  .interstitial-wrapper {<br/>
    margin-top: 7vh;<br/>
  }<br/>
}<br/>
<br/>
@media (min-height: 650px) and (max-width: 414px) and (orientation: portrait) {<br/>
  .interstitial-wrapper {<br/>
    margin-top: 10vh;<br/>
  }<br/>
}<br/>
<br/>
/* Small mobile screens. No fixed nav. */<br/>
@media (max-height: 400px) and (orientation: portrait),<br/>
       (max-height: 239px) and (orientation: landscape),<br/>
       (max-width: 419px) and (max-height: 399px) {<br/>
  .interstitial-wrapper {<br/>
    display: flex;<br/>
    flex-direction: column;<br/>
    margin-bottom: 0;<br/>
  }<br/>
<br/>
  #details {<br/>
    flex: 1 1 auto;<br/>
    order: 0;<br/>
  }<br/>
<br/>
  #main-content {<br/>
    flex: 1 1 auto;<br/>
    order: 0;<br/>
  }<br/>
<br/>
  .nav-wrapper {<br/>
    flex: 0 1 auto;<br/>
    margin-top: 8px;<br/>
    order: 1;<br/>
    padding-inline-end: 0;<br/>
    padding-inline-start: 0;<br/>
    position: relative;<br/>
    width: 100%;<br/>
  }<br/>
<br/>
  button,<br/>
  .nav-wrapper .secondary-button {<br/>
    padding: 16px 24px;<br/>
  }<br/>
<br/>
  button.small-link {<br/>
    color: var(--google-blue-600);<br/>
  }<br/>
}<br/>
<br/>
@media (max-width: 239px) and (orientation: portrait) {<br/>
  .nav-wrapper {<br/>
    padding-inline-end: 0;<br/>
    padding-inline-start: 0;<br/>
  }<br/>
}<br/>
&lt;/style&gt;<br/>
  &lt;style&gt;/* Copyright 2013 The Chromium Authors<br/>
 * Use of this source code is governed by a BSD-style license that can be<br/>
 * found in the LICENSE file. */<br/>
<br/>
/* Don't use the main frame div when the error is in a subframe. */<br/>
html[subframe] #main-frame-error {<br/>
  display: none;<br/>
}<br/>
<br/>
/* Don't use the subframe error div when the error is in a main frame. */<br/>
html:not([subframe]) #sub-frame-error {<br/>
  display: none;<br/>
}<br/>
<br/>
h1 {<br/>
  margin-top: 0;<br/>
  word-wrap: break-word;<br/>
}<br/>
<br/>
h1 span {<br/>
  font-weight: 500;<br/>
}<br/>
<br/>
a {<br/>
  text-decoration: none;<br/>
}<br/>
<br/>
.icon {<br/>
  -webkit-user-select: none;<br/>
  display: inline-block;<br/>
}<br/>
<br/>
.icon-generic {<br/>
  /* Can't access chrome://theme/IDR_ERROR_NETWORK_GENERIC from an untrusted<br/>
   * renderer process, so embed the resource manually. */<br/>
  content: image-set(<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAENJREFUeF7tzbEJACEQRNGBLeAasBCza2lLEGx0CxFGG9hBMDDxRy/72O9FMnIFapGylsu1fgoBdkXfUHLrQgdfrlJN1BdYBjQQm3UAAAAASUVORK5CYII=) 1x,<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQAQMAAADdiHD7AAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAFJJREFUeF7t0cENgDAMQ9FwYgxG6WjpaIzCCAxQxVggFuDiCvlLOeRdHR9yzjncHVoq3npu+wQUrUuJHylSTmBaespJyJQoObUeyxDQb3bEm5Au81c0pSCD8HYAAAAASUVORK5CYII=) 2x);<br/>
}<br/>
<br/>
.icon-info {<br/>
  content: image-set(<br/>
      url(data:image/png;base64,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) 1x,<br/>
      url(data:image/png;base64,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) 2x);<br/>
}<br/>
<br/>
.icon-offline {<br/>
  content: image-set(<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==) 1x,<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQBAMAAAAVaP+LAAAAGFBMVEUAAABTU1NNTU1TU1NPT09SUlJSUlJTU1O8B7DEAAAAB3RSTlMAoArVKvVgBuEdKgAAAJ1JREFUeF7t1TEOwyAMQNG0Q6/UE+RMXD9d/tC6womIFSL9P+MnAYOXeTIzMzMzMzMzaz8J9Ri6HoITmuHXhISE8nEh9yxDh55aCEUoTGbbQwjqHwIkRAEiIaG0+0AA9VBMaE89Rogeoww936MQrWdBr4GN/z0IAdQ6nQ/FIpRXDwHcA+JIJcQowQAlFUA0MfQpXLlVQfkzR4igS6ENjknm/wiaGhsAAAAASUVORK5CYII=) 2x);<br/>
  position: relative;<br/>
}<br/>
<br/>
.icon-disabled {<br/>
  content: image-set(<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAABICAMAAAAZF4G5AAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAASZJREFUeAHd11Fq7jAMRGGf/W/6PoWB67YMqv5DybwG/CFjRuR8JBw3+ByiRjgV9W/TJ31P0tBfC6+cj1haUFXKHmVJo5wP98WwQ0ZCbfUc6LQ6VuUBz31ikADkLMkDrfUC4rR6QGW+gF6rx7NaHWCj1Y/W6lf4L7utvgBSt3rBFSS/XBMPUILcJINHCBWYUfpWn4NBi1ZfudIc3rf6/NGEvEA+AsYTJozmXemjXeLZAov+mnkN2HfzXpMSVQDnGw++57qNJ4D1xitA2sJ+VAWMygSEaYf2mYPTjZfk2K8wmP7HLIH5Mg4/pP+PEcDzUvDMvYbs/2NWwPO5vBdMZE4EE5UTQLiBFDaUlTDPBRoJ9HdAYIkIo06og3BNXtCzy7zA1aXk5x+tJARq63eAygAAAABJRU5ErkJggg==) 1x,<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAACQAQMAAAArwfVjAAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAAYdJREFUeF7F1EFqwzAUBNARAmVj0FZe5QoBH6BX+dn4GlY2PYNzGx/A0CvkCIJuvIraKJKbgBvzf2g62weDGD7CYggpfFReis4J0ey9EGFIiEQQojFSlA9kSIiqd0KkFjKsewgRbStEN19mxUPTtmW9HQ/h6tyqNQ8NlSMZdzyE6qkoE0trVYGFm0n1WYeBhduzwbwBC7voS+vIxfeMjeaiLxsMMtQNwMPtuew+DjzcTHk8YMfDknEcIUOtf2lVfgVH3K4Xv5PRYAXRVMtItIJ3rfaCIVn9DsTH2NxisAVRex2Hh3hX+/mRUR08bAwPEYsI51ZxWH4Q0SpicQRXeyEaIug48FEdegARfMz/tADVsRciwTAxW308ehmC2gLraC+YCbV3QoTZexa+zegAEW5PhhgYfmbvJgcRqngGByOSXdFJcLk2JeDPEN0kxe1JhIt5FiFA+w+ItMELsUyPF2IaJ4aILqb4FbxPwhImwj6JauKgDUCYaxmYIsd4KXdMjIC9ItB5Bn4BNRwsG0XM2nwAAAAASUVORK5CYII=) 2x);<br/>
  width: 112px;<br/>
}<br/>
<br/>
.hidden {<br/>
  display: none;<br/>
}<br/>
<br/>
#suggestions-list a {<br/>
  color: var(--google-blue-600);<br/>
}<br/>
<br/>
#suggestions-list p {<br/>
  margin-block-end: 0;<br/>
}<br/>
<br/>
#suggestions-list ul {<br/>
  margin-top: 0;<br/>
}<br/>
<br/>
.single-suggestion {<br/>
  list-style-type: none;<br/>
  padding-inline-start: 0;<br/>
}<br/>
<br/>
.link-button {<br/>
  color: rgb(66, 133, 244);<br/>
  display: inline-block;<br/>
  font-weight: bold;<br/>
  text-transform: uppercase;<br/>
}<br/>
<br/>
#sub-frame-error-details {<br/>
<br/>
  color: #8F8F8F;<br/>
<br/>
  /* Not done on mobile for performance reasons. */<br/>
  text-shadow: 0 1px 0 rgba(255,255,255,0.3);<br/>
<br/>
}<br/>
<br/>
.secondary-button {<br/>
  background: #d9d9d9;<br/>
  color: #696969;<br/>
  margin-inline-end: 16px;<br/>
}<br/>
<br/>
.snackbar {<br/>
  background: #323232;<br/>
  border-radius: 2px;<br/>
  bottom: 24px;<br/>
  box-sizing: border-box;<br/>
  color: #fff;<br/>
  font-size: .87em;<br/>
  left: 24px;<br/>
  max-width: 568px;<br/>
  min-width: 288px;<br/>
  opacity: 0;<br/>
  padding: 16px 24px 12px;<br/>
  position: fixed;<br/>
  transform: translateY(90px);<br/>
  will-change: opacity, transform;<br/>
  z-index: 999;<br/>
}<br/>
<br/>
.snackbar-show {<br/>
  -webkit-animation:<br/>
    show-snackbar 250ms cubic-bezier(0, 0, 0.2, 1) forwards,<br/>
    hide-snackbar 250ms cubic-bezier(0.4, 0, 1, 1) forwards 5s;<br/>
}<br/>
<br/>
@-webkit-keyframes show-snackbar {<br/>
  100% {<br/>
    opacity: 1;<br/>
    transform: translateY(0);<br/>
  }<br/>
}<br/>
<br/>
@-webkit-keyframes hide-snackbar {<br/>
  0% {<br/>
    opacity: 1;<br/>
    transform: translateY(0);<br/>
  }<br/>
  100% {<br/>
    opacity: 0;<br/>
    transform: translateY(90px);<br/>
  }<br/>
}<br/>
<br/>
.suggestions {<br/>
  margin-top: 18px;<br/>
}<br/>
<br/>
.suggestion-header {<br/>
  font-weight: bold;<br/>
  margin-bottom: 4px;<br/>
}<br/>
<br/>
.suggestion-body {<br/>
  color: #777;<br/>
}<br/>
<br/>
/* Decrease padding at low sizes. */<br/>
@media (max-width: 640px), (max-height: 640px) {<br/>
  h1 {<br/>
    margin: 0 0 15px;<br/>
  }<br/>
  .suggestions {<br/>
    margin-top: 10px;<br/>
  }<br/>
  .suggestion-header {<br/>
    margin-bottom: 0;<br/>
  }<br/>
}<br/>
<br/>
#cancel-save-page-button {<br/>
  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48Y2xpcFBhdGggaWQ9Im1hc2siPjxwYXRoIGQ9Ik0xMiAyQzYuNSAyIDIgNi41IDIgMTJzNC41IDEwIDEwIDEwIDEwLTQuNSAxMC0xMFMxNy41IDIgMTIgMnptNSAxNkg3di0yaDEwdjJ6bS02LjctNEw3IDEwLjdsMS40LTEuNCAxLjkgMS45IDUuMy01LjNMMTcgNy4zIDEwLjMgMTR6IiBmaWxsPSIjOUFBMEE2Ii8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiM5QUEwQTYiIGQ9Ik0wIDBoMjR2MjRIMHoiLz48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiMxQTczRTgiIHN0eWxlPSJhbmltYXRpb246b2ZmbGluZUFuaW1hdGlvbiA0cyBpbmZpbml0ZSIgZD0iTTAgMGgyNHYyNEgweiIvPjxzdHlsZT5Aa2V5ZnJhbWVzIG9mZmxpbmVBbmltYXRpb257MCUsMzUle2hlaWdodDowfTYwJXtoZWlnaHQ6MTAwJX05MCV7ZmlsbC1vcGFjaXR5OjF9dG97ZmlsbC1vcGFjaXR5OjB9fTwvc3R5bGU+PC9zdmc+);<br/>
  background-position: right 27px center;<br/>
  background-repeat: no-repeat;<br/>
  border: 1px solid var(--google-gray-300);<br/>
  border-radius: 5px;<br/>
  color: var(--google-gray-700);<br/>
  margin-bottom: 26px;<br/>
  padding-bottom: 16px;<br/>
  padding-inline-end: 88px;<br/>
  padding-inline-start: 16px;<br/>
  padding-top: 16px;<br/>
  text-align: start;<br/>
}<br/>
<br/>
html[dir='rtl'] #cancel-save-page-button {<br/>
  background-position: left 27px center;<br/>
}<br/>
<br/>
#save-page-for-later-button {<br/>
  display: flex;<br/>
  justify-content: start;<br/>
}<br/>
<br/>
#save-page-for-later-button a::before {<br/>
  content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxLjJlbSIgaGVpZ2h0PSIxLjJlbSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNSAyMGgxNHYtMkg1bTE0LTloLTRWM0g5djZINWw3IDcgNy03eiIgZmlsbD0iIzQyODVGNCIvPjwvc3ZnPg==);<br/>
  display: inline-block;<br/>
  margin-inline-end: 4px;<br/>
  vertical-align: -webkit-baseline-middle;<br/>
}<br/>
<br/>
.hidden#save-page-for-later-button {<br/>
  display: none;<br/>
}<br/>
<br/>
/* Don't allow overflow when in a subframe. */<br/>
html[subframe] body {<br/>
  overflow: hidden;<br/>
}<br/>
<br/>
#sub-frame-error {<br/>
  -webkit-align-items: center;<br/>
  -webkit-flex-flow: column;<br/>
  -webkit-justify-content: center;<br/>
  background-color: #DDD;<br/>
  display: -webkit-flex;<br/>
  height: 100%;<br/>
  left: 0;<br/>
  position: absolute;<br/>
  text-align: center;<br/>
  top: 0;<br/>
  transition: background-color 200ms ease-in-out;<br/>
  width: 100%;<br/>
}<br/>
<br/>
#sub-frame-error:hover {<br/>
  background-color: #EEE;<br/>
}<br/>
<br/>
#sub-frame-error .icon-generic {<br/>
  margin: 0 0 16px;<br/>
}<br/>
<br/>
#sub-frame-error-details {<br/>
  margin: 0 10px;<br/>
  text-align: center;<br/>
  opacity: 0;<br/>
}<br/>
<br/>
/* Show details only when hovering. */<br/>
#sub-frame-error:hover #sub-frame-error-details {<br/>
  opacity: 1;<br/>
}<br/>
<br/>
/* If the iframe is too small, always hide the error code. */<br/>
/* TODO(mmenke): See if overflow: no-display works better, once supported. */<br/>
@media (max-width: 200px), (max-height: 95px) {<br/>
  #sub-frame-error-details {<br/>
    display: none;<br/>
  }<br/>
}<br/>
<br/>
/* Adjust icon for small embedded frames in apps. */<br/>
@media (max-height: 100px) {<br/>
  #sub-frame-error .icon-generic {<br/>
    height: auto;<br/>
    margin: 0;<br/>
    padding-top: 0;<br/>
    width: 25px;<br/>
  }<br/>
}<br/>
<br/>
/* details-button is special; it's a &lt;button&gt; element that looks like a link. */<br/>
#details-button {<br/>
  box-shadow: none;<br/>
  min-width: 0;<br/>
}<br/>
<br/>
/* Styles for platform dependent separation of controls and details button. */<br/>
.suggested-left &gt; #control-buttons,<br/>
.suggested-right &gt; #details-button {<br/>
  float: left;<br/>
}<br/>
<br/>
.suggested-right &gt; #control-buttons,<br/>
.suggested-left &gt; #details-button {<br/>
  float: right;<br/>
}<br/>
<br/>
.suggested-left .secondary-button {<br/>
  margin-inline-end: 0;<br/>
  margin-inline-start: 16px;<br/>
}<br/>
<br/>
#details-button.singular {<br/>
  float: none;<br/>
}<br/>
<br/>
/* download-button shows both icon and text. */<br/>
#download-button {<br/>
  padding-bottom: 4px;<br/>
  padding-top: 4px;<br/>
  position: relative;<br/>
}<br/>
<br/>
#download-button::before {<br/>
  background: image-set(<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAO0lEQVQ4y2NgGArgPxIY1YChsOE/LtBAmpYG0mxpIOSDBpKUo2lpIDZxNJCkHKqlYZAla3RAHQ1DFgAARRroHyLNTwwAAAAASUVORK5CYII=) 1x,<br/>
      url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAQAAAD9CzEMAAAAZElEQVRYw+3Ruw3AMAwDUY3OzZUmRRD4E9iim9wNwAdbEURHyk4AAAAATiCVK8lLyPsKeT9K3lsownnunfkPxO78hKiYHxBV8x2icr5BVM+/CMf8g3DN34Rzns6ViwHUAUQ/6wIAd5Km7l6c8AAAAABJRU5ErkJggg==) 2x)<br/>
    no-repeat;<br/>
  content: '';<br/>
  display: inline-block;<br/>
  height: 24px;<br/>
  margin-inline-end: 4px;<br/>
  margin-inline-start: -4px;<br/>
  vertical-align: middle;<br/>
  width: 24px;<br/>
}<br/>
<br/>
#download-button:disabled {<br/>
  background: rgb(180, 206, 249);<br/>
  color: rgb(255, 255, 255);<br/>
}<br/>
<br/>
#buttons::after {<br/>
  clear: both;<br/>
  content: '';<br/>
  display: block;<br/>
  width: 100%;<br/>
}<br/>
<br/>
/* Offline page */<br/>
html[dir='rtl'] .runner-container,<br/>
html[dir='rtl'].offline .icon-offline {<br/>
  transform: scaleX(-1);<br/>
}<br/>
<br/>
.offline {<br/>
  transition: filter 1.5s cubic-bezier(0.65, 0.05, 0.36, 1),<br/>
              background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);<br/>
<br/>
  will-change: filter, background-color;<br/>
<br/>
}<br/>
<br/>
.offline body {<br/>
  transition: background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);<br/>
}<br/>
<br/>
.offline #main-message &gt; p {<br/>
  display: none;<br/>
}<br/>
<br/>
.offline.inverted {<br/>
  background-color: #fff;<br/>
  filter: invert(1);<br/>
}<br/>
<br/>
.offline.inverted body {<br/>
  background-color: #fff;<br/>
}<br/>
<br/>
.offline .interstitial-wrapper {<br/>
  color: var(--text-color);<br/>
  font-size: 1em;<br/>
  line-height: 1.55;<br/>
  margin: 0 auto;<br/>
  max-width: 600px;<br/>
  padding-top: 100px;<br/>
  position: relative;<br/>
  width: 100%;<br/>
}<br/>
<br/>
.offline .runner-container {<br/>
  direction: ltr;<br/>
  height: 150px;<br/>
  max-width: 600px;<br/>
  overflow: hidden;<br/>
  position: absolute;<br/>
  top: 35px;<br/>
  width: 44px;<br/>
}<br/>
<br/>
.offline .runner-container:focus {<br/>
  outline: none;<br/>
}<br/>
<br/>
.offline .runner-container:focus-visible {<br/>
  outline: 3px solid var(--google-blue-300);<br/>
}<br/>
<br/>
.offline .runner-canvas {<br/>
  height: 150px;<br/>
  max-width: 600px;<br/>
  opacity: 1;<br/>
  overflow: hidden;<br/>
  position: absolute;<br/>
  top: 0;<br/>
  z-index: 10;<br/>
}<br/>
<br/>
.offline .controller {<br/>
  height: 100vh;<br/>
  left: 0;<br/>
  position: absolute;<br/>
  top: 0;<br/>
  width: 100vw;<br/>
  z-index: 9;<br/>
}<br/>
<br/>
#offline-resources {<br/>
  display: none;<br/>
}<br/>
<br/>
#offline-instruction {<br/>
  image-rendering: pixelated;<br/>
  left: 0;<br/>
  margin: auto;<br/>
  position: absolute;<br/>
  right: 0;<br/>
  top: 60px;<br/>
  width: fit-content;<br/>
}<br/>
<br/>
.offline-runner-live-region {<br/>
  bottom: 0;<br/>
  clip-path: polygon(0 0, 0 0, 0 0);<br/>
  color: var(--background-color);<br/>
  display: block;<br/>
  font-size: xx-small;<br/>
  overflow: hidden;<br/>
  position: absolute;<br/>
  text-align: center;<br/>
  transition: color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);<br/>
  user-select: none;<br/>
}<br/>
<br/>
/* Custom toggle */<br/>
.slow-speed-option {<br/>
  align-items: center;<br/>
  background: var(--google-gray-50);<br/>
  border-radius: 24px/50%;<br/>
  bottom: 0;<br/>
  color: var(--error-code-color);<br/>
  display: inline-flex;<br/>
  font-size: 1em;<br/>
  left: 0;<br/>
  line-height: 1.1em;<br/>
  margin: 5px auto;<br/>
  padding: 2px 12px 3px 20px;<br/>
  position: absolute;<br/>
  right: 0;<br/>
  width: max-content;<br/>
  z-index: 999;<br/>
}<br/>
<br/>
.slow-speed-option.hidden {<br/>
  display: none;<br/>
}<br/>
<br/>
.slow-speed-option [type=checkbox] {<br/>
  opacity: 0;<br/>
  pointer-events: none;<br/>
  position: absolute;<br/>
}<br/>
<br/>
.slow-speed-option .slow-speed-toggle {<br/>
  cursor: pointer;<br/>
  margin-inline-start: 8px;<br/>
  padding: 8px 4px;<br/>
  position: relative;<br/>
}<br/>
<br/>
.slow-speed-option [type=checkbox]:disabled ~ .slow-speed-toggle {<br/>
  cursor: default;<br/>
}<br/>
<br/>
.slow-speed-option-label [type=checkbox] {<br/>
  opacity: 0;<br/>
  pointer-events: none;<br/>
  position: absolute;<br/>
}<br/>
<br/>
.slow-speed-option .slow-speed-toggle::before,<br/>
.slow-speed-option .slow-speed-toggle::after {<br/>
  content: '';<br/>
  display: block;<br/>
  margin: 0 3px;<br/>
  transition: all 100ms cubic-bezier(0.4, 0, 1, 1);<br/>
}<br/>
<br/>
.slow-speed-option .slow-speed-toggle::before {<br/>
  background: rgb(189,193,198);<br/>
  border-radius: 0.65em;<br/>
  height: 0.9em;<br/>
  width: 2em;<br/>
}<br/>
<br/>
.slow-speed-option .slow-speed-toggle::after {<br/>
  background: #fff;<br/>
  border-radius: 50%;<br/>
  box-shadow: 0 1px 3px 0 rgb(0 0 0 / 40%);<br/>
  height: 1.2em;<br/>
  position: absolute;<br/>
  top: 51%;<br/>
  transform: translate(-20%, -50%);<br/>
  width: 1.1em;<br/>
}<br/>
<br/>
.slow-speed-option [type=checkbox]:focus + .slow-speed-toggle {<br/>
  box-shadow: 0 0 8px rgb(94, 158, 214);<br/>
  outline: 1px solid rgb(93, 157, 213);<br/>
}<br/>
<br/>
.slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::before {<br/>
  background: var(--google-blue-600);<br/>
  opacity: 0.5;<br/>
}<br/>
<br/>
.slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::after {<br/>
  background: var(--google-blue-600);<br/>
  transform: translate(calc(2em - 90%), -50%);<br/>
}<br/>
<br/>
.slow-speed-option [type=checkbox]:checked:disabled +<br/>
  .slow-speed-toggle::before {<br/>
  background: rgb(189,193,198);<br/>
}<br/>
<br/>
.slow-speed-option [type=checkbox]:checked:disabled +<br/>
  .slow-speed-toggle::after {<br/>
  background: var(--google-gray-50);<br/>
}<br/>
<br/>
@media (max-width: 420px) {<br/>
  #download-button {<br/>
    padding-bottom: 12px;<br/>
    padding-top: 12px;<br/>
  }<br/>
<br/>
  .suggested-left &gt; #control-buttons,<br/>
  .suggested-right &gt; #control-buttons {<br/>
    float: none;<br/>
  }<br/>
<br/>
  .snackbar {<br/>
    border-radius: 0;<br/>
    bottom: 0;<br/>
    left: 0;<br/>
    width: 100%;<br/>
  }<br/>
}<br/>
<br/>
@media (max-height: 350px) {<br/>
  h1 {<br/>
    margin: 0 0 15px;<br/>
  }<br/>
<br/>
  .icon-offline {<br/>
    margin: 0 0 10px;<br/>
  }<br/>
<br/>
  .interstitial-wrapper {<br/>
    margin-top: 5%;<br/>
  }<br/>
<br/>
  .nav-wrapper {<br/>
    margin-top: 30px;<br/>
  }<br/>
}<br/>
<br/>
@media (min-width: 420px) and (max-width: 736px) and<br/>
       (min-height: 240px) and (max-height: 420px) and<br/>
       (orientation:landscape) {<br/>
  .interstitial-wrapper {<br/>
    margin-bottom: 100px;<br/>
  }<br/>
}<br/>
<br/>
@media (max-width: 360px) and (max-height: 480px) {<br/>
  .offline .interstitial-wrapper {<br/>
    padding-top: 60px;<br/>
  }<br/>
<br/>
  .offline .runner-container {<br/>
    top: 8px;<br/>
  }<br/>
}<br/>
<br/>
@media (min-height: 240px) and (orientation: landscape) {<br/>
  .offline .interstitial-wrapper {<br/>
    margin-bottom: 90px;<br/>
  }<br/>
<br/>
  .icon-offline {<br/>
    margin-bottom: 20px;<br/>
  }<br/>
}<br/>
<br/>
@media (max-height: 320px) and (orientation: landscape) {<br/>
  .icon-offline {<br/>
    margin-bottom: 0;<br/>
  }<br/>
<br/>
  .offline .runner-container {<br/>
    top: 10px;<br/>
  }<br/>
}<br/>
<br/>
@media (max-width: 240px) {<br/>
  button {<br/>
    padding-inline-end: 12px;<br/>
    padding-inline-start: 12px;<br/>
  }<br/>
<br/>
  .interstitial-wrapper {<br/>
    overflow: inherit;<br/>
    padding: 0 8px;<br/>
  }<br/>
}<br/>
<br/>
@media (max-width: 120px) {<br/>
  button {<br/>
    width: auto;<br/>
  }<br/>
}<br/>
<br/>
.arcade-mode,<br/>
.arcade-mode .runner-container,<br/>
.arcade-mode .runner-canvas {<br/>
  image-rendering: pixelated;<br/>
  max-width: 100%;<br/>
  overflow: hidden;<br/>
}<br/>
<br/>
.arcade-mode #buttons,<br/>
.arcade-mode #main-content {<br/>
  opacity: 0;<br/>
  overflow: hidden;<br/>
}<br/>
<br/>
.arcade-mode .interstitial-wrapper {<br/>
  height: 100vh;<br/>
  max-width: 100%;<br/>
  overflow: hidden;<br/>
}<br/>
<br/>
.arcade-mode .runner-container {<br/>
  left: 0;<br/>
  margin: auto;<br/>
  right: 0;<br/>
  transform-origin: top center;<br/>
  transition: transform 250ms cubic-bezier(0.4, 0, 1, 1) 400ms;<br/>
  z-index: 2;<br/>
}<br/>
<br/>
@media (prefers-color-scheme: dark) {<br/>
  .icon {<br/>
    filter: invert(1);<br/>
  }<br/>
<br/>
  .offline .runner-canvas {<br/>
    filter: invert(1);<br/>
  }<br/>
<br/>
  .offline.inverted {<br/>
    background-color: var(--background-color);<br/>
    filter: invert(0);<br/>
  }<br/>
<br/>
  .offline.inverted body {<br/>
    background-color: #fff;<br/>
  }<br/>
<br/>
  .offline.inverted .offline-runner-live-region {<br/>
    color: #fff;<br/>
  }<br/>
<br/>
  #suggestions-list a {<br/>
    color: var(--link-color);<br/>
  }<br/>
<br/>
  .slow-speed-option {<br/>
    background: var(--google-gray-800);<br/>
    color: var(--google-gray-100);<br/>
  }<br/>
<br/>
  .slow-speed-option .slow-speed-toggle::before,<br/>
  .slow-speed-option [type=checkbox]:checked:disabled +<br/>
    .slow-speed-toggle::before {<br/>
     background: rgb(189,193,198);<br/>
  }<br/>
<br/>
  .slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::after,<br/>
  .slow-speed-option [type=checkbox]:checked + .slow-speed-toggle::before {<br/>
    background: var(--google-blue-300);<br/>
  }<br/>
}<br/>
<br/>
#main-frame-error:not(.showing-details) #details {<br/>
  display: none;<br/>
}<br/>
<br/>
@media (min-width: 240px) and (max-width: 420px) and (min-height: 401px),<br/>
       (min-height: 240px) and (max-height: 560px) and (min-width: 421px) {<br/>
  #main-frame-error.showing-details #main-content,<br/>
  #main-frame-error.showing-details .runner-container {<br/>
    display: none;<br/>
  }<br/>
}<br/>
&lt;/style&gt;<br/>
  &lt;script&gt;// Copyright 2022 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/**<br/>
 * Verify |value| is truthy.<br/>
 * @param value A value to check for truthiness. Note that this<br/>
 *     may be used to test whether |value| is defined or not, and we don't want<br/>
 *     to force a cast to boolean.<br/>
 */<br/>
function assert(value, message) {<br/>
    if (value) {<br/>
        return;<br/>
    }<br/>
    throw new Error('Assertion failed' + (message ? `: ${message}` : ''));<br/>
}<br/>
<br/>
// Copyright 2022 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/**<br/>
 * @fileoverview This file defines a singleton which provides access to all data<br/>
 * that is available as soon as the page's resources are loaded (before DOM<br/>
 * content has finished loading). This data includes both localized strings and<br/>
 * any data that is important to have ready from a very early stage (e.g. things<br/>
 * that must be displayed right away).<br/>
 *<br/>
 * Note that loadTimeData is not guaranteed to be consistent between page<br/>
 * refreshes (https://crbug.com/740629) and should not contain values that might<br/>
 * change if the page is re-opened later.<br/>
 */<br/>
class LoadTimeData {<br/>
    data_ = null;<br/>
    /**<br/>
     * Sets the backing object.<br/>
     *<br/>
     * Note that there is no getter for |data_| to discourage abuse of the form:<br/>
     *<br/>
     *     var value = loadTimeData.data()['key'];<br/>
     */<br/>
    set data(value) {<br/>
        assert(!this.data_, 'Re-setting data.');<br/>
        this.data_ = value;<br/>
    }<br/>
    /**<br/>
     * @param id An ID of a value that might exist.<br/>
     * @return True if |id| is a key in the dictionary.<br/>
     */<br/>
    valueExists(id) {<br/>
        assert(this.data_, 'No data. Did you remember to include strings.js?');<br/>
        return id in this.data_;<br/>
    }<br/>
    /**<br/>
     * Fetches a value, expecting that it exists.<br/>
     * @param id The key that identifies the desired value.<br/>
     * @return The corresponding value.<br/>
     */<br/>
    getValue(id) {<br/>
        assert(this.data_, 'No data. Did you remember to include strings.js?');<br/>
        const value = this.data_[id];<br/>
        assert(typeof value !== 'undefined', 'Could not find value for ' + id);<br/>
        return value;<br/>
    }<br/>
    /**<br/>
     * As above, but also makes sure that the value is a string.<br/>
     * @param id The key that identifies the desired string.<br/>
     * @return The corresponding string value.<br/>
     */<br/>
    getString(id) {<br/>
        const value = this.getValue(id);<br/>
        assert(typeof value === 'string', `[${value}] (${id}) is not a string`);<br/>
        return value;<br/>
    }<br/>
    /**<br/>
     * Returns a formatted localized string where $1 to $9 are replaced by the<br/>
     * second to the tenth argument.<br/>
     * @param id The ID of the string we want.<br/>
     * @param args The extra values to include in the formatted output.<br/>
     * @return The formatted string.<br/>
     */<br/>
    getStringF(id, ...args) {<br/>
        const value = this.getString(id);<br/>
        if (!value) {<br/>
            return '';<br/>
        }<br/>
        return this.substituteString(value, ...args);<br/>
    }<br/>
    /**<br/>
     * Returns a formatted localized string where $1 to $9 are replaced by the<br/>
     * second to the tenth argument. Any standalone $ signs must be escaped as<br/>
     * $$.<br/>
     * @param label The label to substitute through. This is not an resource ID.<br/>
     * @param args The extra values to include in the formatted output.<br/>
     * @return The formatted string.<br/>
     */<br/>
    substituteString(label, ...args) {<br/>
        return label.replace(/\$(.|$|\n)/g, function (m) {<br/>
            assert(m.match(/\$[$1-9]/), 'Unescaped $ found in localized string.');<br/>
            if (m === '$$') {<br/>
                return '$';<br/>
            }<br/>
            const substitute = args[Number(m[1]) - 1];<br/>
            if (substitute === undefined || substitute === null) {<br/>
                // Not all callers actually provide values for all substitutes. Return<br/>
                // an empty value for this case.<br/>
                return '';<br/>
            }<br/>
            return substitute.toString();<br/>
        });<br/>
    }<br/>
    /**<br/>
     * Returns a formatted string where $1 to $9 are replaced by the second to<br/>
     * tenth argument, split apart into a list of pieces describing how the<br/>
     * substitution was performed. Any standalone $ signs must be escaped as $$.<br/>
     * @param label A localized string to substitute through.<br/>
     *     This is not an resource ID.<br/>
     * @param args The extra values to include in the formatted output.<br/>
     * @return The formatted string pieces.<br/>
     */<br/>
    getSubstitutedStringPieces(label, ...args) {<br/>
        // Split the string by separately matching all occurrences of $1-9 and of<br/>
        // non $1-9 pieces.<br/>
        const pieces = (label.match(/(\$[1-9])|(([^$]|\$([^1-9]|$))+)/g) ||<br/>
            []).map(function (p) {<br/>
            // Pieces that are not $1-9 should be returned after replacing $$<br/>
            // with $.<br/>
            if (!p.match(/^\$[1-9]$/)) {<br/>
                assert((p.match(/\$/g) || []).length % 2 === 0, 'Unescaped $ found in localized string.');<br/>
                return { value: p.replace(/\$\$/g, '$'), arg: null };<br/>
            }<br/>
            // Otherwise, return the substitution value.<br/>
            const substitute = args[Number(p[1]) - 1];<br/>
            if (substitute === undefined || substitute === null) {<br/>
                // Not all callers actually provide values for all substitutes. Return<br/>
                // an empty value for this case.<br/>
                return { value: '', arg: p };<br/>
            }<br/>
            return { value: substitute.toString(), arg: p };<br/>
        });<br/>
        return pieces;<br/>
    }<br/>
    /**<br/>
     * As above, but also makes sure that the value is a boolean.<br/>
     * @param id The key that identifies the desired boolean.<br/>
     * @return The corresponding boolean value.<br/>
     */<br/>
    getBoolean(id) {<br/>
        const value = this.getValue(id);<br/>
        assert(typeof value === 'boolean', `[${value}] (${id}) is not a boolean`);<br/>
        return value;<br/>
    }<br/>
    /**<br/>
     * As above, but also makes sure that the value is an integer.<br/>
     * @param id The key that identifies the desired number.<br/>
     * @return The corresponding number value.<br/>
     */<br/>
    getInteger(id) {<br/>
        const value = this.getValue(id);<br/>
        assert(typeof value === 'number', `[${value}] (${id}) is not a number`);<br/>
        assert(value === Math.floor(value), 'Number isn\'t integer: ' + value);<br/>
        return value;<br/>
    }<br/>
    /**<br/>
     * Override values in loadTimeData with the values found in |replacements|.<br/>
     * @param replacements The dictionary object of keys to replace.<br/>
     */<br/>
    overrideValues(replacements) {<br/>
        assert(typeof replacements === 'object', 'Replacements must be a dictionary object.');<br/>
        assert(this.data_, 'Data must exist before being overridden');<br/>
        for (const key in replacements) {<br/>
            this.data_[key] = replacements[key];<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Reset loadTimeData's data. Should only be used in tests.<br/>
     * @param newData The data to restore to, when null restores to unset state.<br/>
     */<br/>
    resetForTesting(newData = null) {<br/>
        this.data_ = newData;<br/>
    }<br/>
    /**<br/>
     * @return Whether loadTimeData.data has been set.<br/>
     */<br/>
    isInitialized() {<br/>
        return this.data_ !== null;<br/>
    }<br/>
}<br/>
const loadTimeData = new LoadTimeData();<br/>
<br/>
// Copyright 2022 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/**<br/>
 * Alias for document.getElementById. Found elements must be HTMLElements.<br/>
 */<br/>
function getRequiredElement(id) {<br/>
    const el = document.querySelector(`#${id}`);<br/>
    assert(el);<br/>
    assert(el instanceof HTMLElement);<br/>
    return el;<br/>
}<br/>
<br/>
/**<br/>
 * @license<br/>
 * Copyright 2019 Google LLC<br/>
 * SPDX-License-Identifier: BSD-3-Clause<br/>
 */<br/>
const t$3=globalThis,e$3=t$3.ShadowRoot&&(void 0===t$3.ShadyCSS||t$3.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),o$3=new WeakMap;let n$3=class n{constructor(t,e,o){if(this._$cssResult$=!0,o!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=t,this.t=e;}get styleSheet(){let t=this.o;const s=this.t;if(e$3&&void 0===t){const e=void 0!==s&&1===s.length;e&&(t=o$3.get(s)),void 0===t&&((this.o=t=new CSSStyleSheet).replaceSync(this.cssText),e&&o$3.set(s,t));}return t}toString(){return this.cssText}};const r$4=t=&gt;new n$3("string"==typeof t?t:t+"",void 0,s$3),S$1=(s,o)=&gt;{if(e$3)s.adoptedStyleSheets=o.map((t=&gt;t instanceof CSSStyleSheet?t:t.styleSheet));else for(const e of o){const o=document.createElement("style"),n=t$3.litNonce;void 0!==n&&o.setAttribute("nonce",n),o.textContent=e.cssText,s.appendChild(o);}},c$3=e$3?t=&gt;t:t=&gt;t instanceof CSSStyleSheet?(t=&gt;{let e="";for(const s of t.cssRules)e+=s.cssText;return r$4(e)})(t):t<br/>
/**<br/>
 * @license<br/>
 * Copyright 2017 Google LLC<br/>
 * SPDX-License-Identifier: BSD-3-Clause<br/>
 */;const{is:i$2,defineProperty:e$2,getOwnPropertyDescriptor:r$3,getOwnPropertyNames:h$2,getOwnPropertySymbols:o$2,getPrototypeOf:n$2}=Object,a$1=globalThis,c$2=a$1.trustedTypes,l$1=c$2?c$2.emptyScript:"",p$1=a$1.reactiveElementPolyfillSupport,d$1=(t,s)=&gt;t,u$1={toAttribute(t,s){switch(s){case Boolean:t=t?l$1:null;break;case Object:case Array:t=null==t?t:JSON.stringify(t);}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t);}catch(t){i=null;}}return i}},f$3=(t,s)=&gt;!i$2(t,s),y$1={attribute:!0,type:String,converter:u$1,reflect:!1,hasChanged:f$3};Symbol.metadata??=Symbol("metadata"),a$1.litPropertyMetadata??=new WeakMap;class b extends HTMLElement{static addInitializer(t){this._$Ei(),(this.l??=[]).push(t);}static get observedAttributes(){return this.finalize(),this._$Eh&&[...this._$Eh.keys()]}static createProperty(t,s=y$1){if(s.state&&(s.attribute=!1),this._$Ei(),this.elementProperties.set(t,s),!s.noAccessor){const i=Symbol(),r=this.getPropertyDescriptor(t,i,s);void 0!==r&&e$2(this.prototype,t,r);}}static getPropertyDescriptor(t,s,i){const{get:e,set:h}=r$3(this.prototype,t)??{get(){return this[s]},set(t){this[s]=t;}};return {get(){return e?.call(this)},set(s){const r=e?.call(this);h.call(this,s),this.requestUpdate(t,r,i);},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)??y$1}static _$Ei(){if(this.hasOwnProperty(d$1("elementProperties")))return;const t=n$2(this);t.finalize(),void 0!==t.l&&(this.l=[...t.l]),this.elementProperties=new Map(t.elementProperties);}static finalize(){if(this.hasOwnProperty(d$1("finalized")))return;if(this.finalized=!0,this._$Ei(),this.hasOwnProperty(d$1("properties"))){const t=this.properties,s=[...h$2(t),...o$2(t)];for(const i of s)this.createProperty(i,t[i]);}const t=this[Symbol.metadata];if(null!==t){const s=litPropertyMetadata.get(t);if(void 0!==s)for(const[t,i]of s)this.elementProperties.set(t,i);}this._$Eh=new Map;for(const[t,s]of this.elementProperties){const i=this._$Eu(t,s);void 0!==i&&this._$Eh.set(i,t);}this.elementStyles=this.finalizeStyles(this.styles);}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(c$3(s));}else void 0!==s&&i.push(c$3(s));return i}static _$Eu(t,s){const i=s.attribute;return !1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}constructor(){super(),this._$Ep=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this._$Em=null,this._$Ev();}_$Ev(){this._$Eg=new Promise((t=&gt;this.enableUpdating=t)),this._$AL=new Map,this._$ES(),this.requestUpdate(),this.constructor.l?.forEach((t=&gt;t(this)));}addController(t){(this._$E_??=new Set).add(t),void 0!==this.renderRoot&&this.isConnected&&t.hostConnected?.();}removeController(t){this._$E_?.delete(t);}_$ES(){const t=new Map,s=this.constructor.elementProperties;for(const i of s.keys())this.hasOwnProperty(i)&&(t.set(i,this[i]),delete this[i]);t.size&gt;0&&(this._$Ep=t);}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return S$1(t,this.constructor.elementStyles),t}connectedCallback(){this.renderRoot??=this.createRenderRoot(),this.enableUpdating(!0),this._$E_?.forEach((t=&gt;t.hostConnected?.()));}enableUpdating(t){}disconnectedCallback(){this._$E_?.forEach((t=&gt;t.hostDisconnected?.()));}attributeChangedCallback(t,s,i){this._$AK(t,i);}_$EO(t,s){const i=this.constructor.elementProperties.get(t),e=this.constructor._$Eu(t,i);if(void 0!==e&&!0===i.reflect){const r=(void 0!==i.converter?.toAttribute?i.converter:u$1).toAttribute(s,i.type);this._$Em=t,null==r?this.removeAttribute(e):this.setAttribute(e,r),this._$Em=null;}}_$AK(t,s){const i=this.constructor,e=i._$Eh.get(t);if(void 0!==e&&this._$Em!==e){const t=i.getPropertyOptions(e),r="function"==typeof t.converter?{fromAttribute:t.converter}:void 0!==t.converter?.fromAttribute?t.converter:u$1;this._$Em=e,this[e]=r.fromAttribute(s,t.type),this._$Em=null;}}requestUpdate(t,s,i,e=!1,r){if(void 0!==t){if(i??=this.constructor.getPropertyOptions(t),!(i.hasChanged??f$3)(e?r:this[t],s))return;this.C(t,s,i);}!1===this.isUpdatePending&&(this._$Eg=this._$EP());}C(t,s,i){this._$AL.has(t)||this._$AL.set(t,s),!0===i.reflect&&this._$Em!==t&&(this._$Ej??=new Set).add(t);}async _$EP(){this.isUpdatePending=!0;try{await this._$Eg;}catch(t){Promise.reject(t);}const t=this.scheduleUpdate();return null!=t&&await t,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){if(!this.isUpdatePending)return;if(!this.hasUpdated){if(this.renderRoot??=this.createRenderRoot(),this._$Ep){for(const[t,s]of this._$Ep)this[t]=s;this._$Ep=void 0;}const t=this.constructor.elementProperties;if(t.size&gt;0)for(const[s,i]of t)!0!==i.wrapped||this._$AL.has(s)||void 0===this[s]||this.C(s,this[s],i);}let t=!1;const s=this._$AL;try{t=this.shouldUpdate(s),t?(this.willUpdate(s),this._$E_?.forEach((t=&gt;t.hostUpdate?.())),this.update(s)):this._$ET();}catch(s){throw t=!1,this._$ET(),s}t&&this._$AE(s);}willUpdate(t){}_$AE(t){this._$E_?.forEach((t=&gt;t.hostUpdated?.())),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.updated(t);}_$ET(){this._$AL=new Map,this.isUpdatePending=!1;}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$Eg}shouldUpdate(t){return !0}update(t){this._$Ej&&=this._$Ej.forEach((t=&gt;this._$EO(t,this[t]))),this._$ET();}updated(t){}firstUpdated(t){}}b.elementStyles=[],b.shadowRootOptions={mode:"open"},b[d$1("elementProperties")]=new Map,b[d$1("finalized")]=new Map,p$1?.({ReactiveElement:b}),(a$1.reactiveElementVersions??=[]).push("2.0.2");<br/>
/**<br/>
 * @license<br/>
 * Copyright 2017 Google LLC<br/>
 * SPDX-License-Identifier: BSD-3-Clause<br/>
 */const t$2=globalThis,i$1=t$2.trustedTypes,s$2=i$1?i$1.createPolicy("lit-html-desktop",{createHTML:t=&gt;t}):void 0,e$1="$lit$",h$1=`lit$${(Math.random()+"").slice(9)}$`,o$1="?"+h$1,n$1=`&lt;${o$1}&gt;`,r$2=document,l=()=&gt;r$2.createComment(""),c$1=t=&gt;null===t||"object"!=typeof t&&"function"!=typeof t,a=Array.isArray,u=t=&gt;a(t)||"function"==typeof t?.[Symbol.iterator],d="[ \t\n\f\r]",f$2=/&lt;(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^&gt;\s]*)|(\/?$))/g,v=/--&gt;/g,_=/&gt;/g,m=RegExp(`&gt;|${d}(?:([^\\s"'&gt;=/]+)(${d}*=${d}*(?:[^ \t\n\f\r"'\`&lt;&gt;=]|("|')|))|$)`,"g"),p=/'/g,g=/"/g,$=/^(?:script|style|textarea|title)$/i,y=t=&gt;(i,...s)=&gt;({_$litType$:t,strings:i,values:s}),x=y(1),w=Symbol.for("lit-noChange"),T=Symbol.for("lit-nothing"),A=new WeakMap,E=r$2.createTreeWalker(r$2,129);function C(t,i){if(!Array.isArray(t)||!t.hasOwnProperty("raw"))throw Error("invalid template strings array");return void 0!==s$2?s$2.createHTML(i):i}const P=(t,i)=&gt;{const s=t.length-1,o=[];let r,l=2===i?"&lt;svg&gt;":"",c=f$2;for(let i=0;i&lt;s;i++){const s=t[i];let a,u,d=-1,y=0;for(;y&lt;s.length&&(c.lastIndex=y,u=c.exec(s),null!==u);)y=c.lastIndex,c===f$2?"!--"===u[1]?c=v:void 0!==u[1]?c=_:void 0!==u[2]?($.test(u[2])&&(r=RegExp("&lt;/"+u[2],"g")),c=m):void 0!==u[3]&&(c=m):c===m?"&gt;"===u[0]?(c=r??f$2,d=-1):void 0===u[1]?d=-2:(d=c.lastIndex-u[2].length,a=u[1],c=void 0===u[3]?m:'"'===u[3]?g:p):c===g||c===p?c=m:c===v||c===_?c=f$2:(c=m,r=void 0);const x=c===m&&t[i+1].startsWith("/&gt;")?" ":"";l+=c===f$2?s+n$1:d&gt;=0?(o.push(a),s.slice(0,d)+e$1+s.slice(d)+h$1+x):s+h$1+(-2===d?i:x);}return [C(t,l+(t[s]||"&lt;?&gt;")+(2===i?"&lt;/svg&gt;":"")),o]};class V{constructor({strings:t,_$litType$:s},n){let r;this.parts=[];let c=0,a=0;const u=t.length-1,d=this.parts,[f,v]=P(t,s);if(this.el=V.createElement(f,n),E.currentNode=this.el.content,2===s){const t=this.el.content.firstChild;t.replaceWith(...t.childNodes);}for(;null!==(r=E.nextNode())&&d.length&lt;u;){if(1===r.nodeType){if(r.hasAttributes())for(const t of r.getAttributeNames())if(t.endsWith(e$1)){const i=v[a++],s=r.getAttribute(t).split(h$1),e=/([.?@])?(.*)/.exec(i);d.push({type:1,index:c,name:e[2],strings:s,ctor:"."===e[1]?k:"?"===e[1]?H:"@"===e[1]?I:R}),r.removeAttribute(t);}else t.startsWith(h$1)&&(d.push({type:6,index:c}),r.removeAttribute(t));if($.test(r.tagName)){const t=r.textContent.split(h$1),s=t.length-1;if(s&gt;0){r.textContent=i$1?i$1.emptyScript:"";for(let i=0;i&lt;s;i++)r.append(t[i],l()),E.nextNode(),d.push({type:2,index:++c});r.append(t[s],l());}}}else if(8===r.nodeType)if(r.data===o$1)d.push({type:2,index:c});else {let t=-1;for(;-1!==(t=r.data.indexOf(h$1,t+1));)d.push({type:7,index:c}),t+=h$1.length-1;}c++;}}static createElement(t,i){const s=r$2.createElement("template");return s.innerHTML=t,s}}function N(t,i,s=t,e){if(i===w)return i;let h=void 0!==e?s._$Co?.[e]:s._$Cl;const o=c$1(i)?void 0:i._$litDirective$;return h?.constructor!==o&&(h?._$AO?.(!1),void 0===o?h=void 0:(h=new o(t),h._$AT(t,s,e)),void 0!==e?(s._$Co??=[])[e]=h:s._$Cl=h),void 0!==h&&(i=N(t,h._$AS(t,i.values),h,e)),i}class S{constructor(t,i){this._$AV=[],this._$AN=void 0,this._$AD=t,this._$AM=i;}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(t){const{el:{content:i},parts:s}=this._$AD,e=(t?.creationScope??r$2).importNode(i,!0);E.currentNode=e;let h=E.nextNode(),o=0,n=0,l=s[0];for(;void 0!==l;){if(o===l.index){let i;2===l.type?i=new M(h,h.nextSibling,this,t):1===l.type?i=new l.ctor(h,l.name,l.strings,this,t):6===l.type&&(i=new L(h,this,t)),this._$AV.push(i),l=s[++n];}o!==l?.index&&(h=E.nextNode(),o++);}return E.currentNode=r$2,e}p(t){let i=0;for(const s of this._$AV)void 0!==s&&(void 0!==s.strings?(s._$AI(t,s,i),i+=s.strings.length-2):s._$AI(t[i])),i++;}}class M{get _$AU(){return this._$AM?._$AU??this._$Cv}constructor(t,i,s,e){this.type=2,this._$AH=T,this._$AN=void 0,this._$AA=t,this._$AB=i,this._$AM=s,this.options=e,this._$Cv=e?.isConnected??!0;}get parentNode(){let t=this._$AA.parentNode;const i=this._$AM;return void 0!==i&&11===t?.nodeType&&(t=i.parentNode),t}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(t,i=this){t=N(this,t,i),c$1(t)?t===T||null==t||""===t?(this._$AH!==T&&this._$AR(),this._$AH=T):t!==this._$AH&&t!==w&&this._(t):void 0!==t._$litType$?this.g(t):void 0!==t.nodeType?this.$(t):u(t)?this.T(t):this._(t);}k(t){return this._$AA.parentNode.insertBefore(t,this._$AB)}$(t){this._$AH!==t&&(this._$AR(),this._$AH=this.k(t));}_(t){this._$AH!==T&&c$1(this._$AH)?this._$AA.nextSibling.data=t:this.$(r$2.createTextNode(t)),this._$AH=t;}g(t){const{values:i,_$litType$:s}=t,e="number"==typeof s?this._$AC(t):(void 0===s.el&&(s.el=V.createElement(C(s.h,s.h[0]),this.options)),s);if(this._$AH?._$AD===e)this._$AH.p(i);else {const t=new S(e,this),s=t.u(this.options);t.p(i),this.$(s),this._$AH=t;}}_$AC(t){let i=A.get(t.strings);return void 0===i&&A.set(t.strings,i=new V(t)),i}T(t){a(this._$AH)||(this._$AH=[],this._$AR());const i=this._$AH;let s,e=0;for(const h of t)e===i.length?i.push(s=new M(this.k(l()),this.k(l()),this,this.options)):s=i[e],s._$AI(h),e++;e&lt;i.length&&(this._$AR(s&&s._$AB.nextSibling,e),i.length=e);}_$AR(t=this._$AA.nextSibling,i){for(this._$AP?.(!1,!0,i);t&&t!==this._$AB;){const i=t.nextSibling;t.remove(),t=i;}}setConnected(t){void 0===this._$AM&&(this._$Cv=t,this._$AP?.(t));}}class R{get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}constructor(t,i,s,e,h){this.type=1,this._$AH=T,this._$AN=void 0,this.element=t,this.name=i,this._$AM=e,this.options=h,s.length&gt;2||""!==s[0]||""!==s[1]?(this._$AH=Array(s.length-1).fill(new String),this.strings=s):this._$AH=T;}_$AI(t,i=this,s,e){const h=this.strings;let o=!1;if(void 0===h)t=N(this,t,i,0),o=!c$1(t)||t!==this._$AH&&t!==w,o&&(this._$AH=t);else {const e=t;let n,r;for(t=h[0],n=0;n&lt;h.length-1;n++)r=N(this,e[s+n],i,n),r===w&&(r=this._$AH[n]),o||=!c$1(r)||r!==this._$AH[n],r===T?t=T:t!==T&&(t+=(r??"")+h[n+1]),this._$AH[n]=r;}o&&!e&&this.O(t);}O(t){t===T?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,t??"");}}class k extends R{constructor(){super(...arguments),this.type=3;}O(t){this.element[this.name]=t===T?void 0:t;}}class H extends R{constructor(){super(...arguments),this.type=4;}O(t){this.element.toggleAttribute(this.name,!!t&&t!==T);}}class I extends R{constructor(t,i,s,e,h){super(t,i,s,e,h),this.type=5;}_$AI(t,i=this){if((t=N(this,t,i,0)??T)===w)return;const s=this._$AH,e=t===T&&s!==T||t.capture!==s.capture||t.once!==s.once||t.passive!==s.passive,h=t!==T&&(s===T||e);e&&this.element.removeEventListener(this.name,this,s),h&&this.element.addEventListener(this.name,this,t),this._$AH=t;}handleEvent(t){"function"==typeof this._$AH?this._$AH.call(this.options?.host??this.element,t):this._$AH.handleEvent(t);}}class L{constructor(t,i,s){this.element=t,this.type=6,this._$AN=void 0,this._$AM=i,this.options=s;}get _$AU(){return this._$AM._$AU}_$AI(t){N(this,t);}}const Z=t$2.litHtmlPolyfillSupport;Z?.(V,M),(t$2.litHtmlVersions??=[]).push("3.1.0");const j=(t,i,s)=&gt;{const e=s?.renderBefore??i;let h=e._$litPart$;if(void 0===h){const t=s?.renderBefore??null;e._$litPart$=h=new M(i.insertBefore(l(),t),t,void 0,s??{});}return h._$AI(t),h<br/>
/**<br/>
 * @license<br/>
 * Copyright 2017 Google LLC<br/>
 * SPDX-License-Identifier: BSD-3-Clause<br/>
 */};let s$1=class s extends b{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0;}createRenderRoot(){const t=super.createRenderRoot();return this.renderOptions.renderBefore??=t.firstChild,t}update(t){const i=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(t),this._$Do=j(i,this.renderRoot,this.renderOptions);}connectedCallback(){super.connectedCallback(),this._$Do?.setConnected(!0);}disconnectedCallback(){super.disconnectedCallback(),this._$Do?.setConnected(!1);}render(){return w}};s$1._$litElement$=!0,s$1["finalized"]=!0,globalThis.litElementHydrateSupport?.({LitElement:s$1});const r$1=globalThis.litElementPolyfillSupport;r$1?.({LitElement:s$1});(globalThis.litElementVersions??=[]).push("4.0.2");<br/>
<br/>
// Copyright 2023 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
const HIDDEN_CLASS = 'hidden';<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
const IS_IOS = /CriOS/.test(window.navigator.userAgent);<br/>
const IS_HIDPI = window.devicePixelRatio &gt; 1;<br/>
const IS_MOBILE = /Android/.test(window.navigator.userAgent) || IS_IOS;<br/>
const IS_RTL = document.documentElement.dir === 'rtl';<br/>
/**<br/>
 * Frames per second.<br/>
 * @const<br/>
 */<br/>
const FPS = 60;<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/**<br/>
 * Get random number.<br/>
 * @param {number} min<br/>
 * @param {number} max<br/>
 */<br/>
function getRandomNum(min, max) {<br/>
    return Math.floor(Math.random() * (max - min + 1)) + min;<br/>
}<br/>
/**<br/>
 * Return the current timestamp.<br/>
 * @return {number}<br/>
 */<br/>
function getTimeStamp() {<br/>
    return IS_IOS ? new Date().getTime() : performance.now();<br/>
}<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class DistanceMeter {<br/>
    /**<br/>
     * Handles displaying the distance meter.<br/>
     * @param {!HTMLCanvasElement} canvas<br/>
     * @param {Object} spritePos Image position in sprite.<br/>
     * @param {number} canvasWidth<br/>
     */<br/>
    constructor(canvas, spritePos, canvasWidth) {<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));<br/>
        this.image = Runner.imageSprite;<br/>
        this.spritePos = spritePos;<br/>
        this.x = 0;<br/>
        this.y = 5;<br/>
        this.currentDistance = 0;<br/>
        this.maxScore = 0;<br/>
        this.highScore = '0';<br/>
        this.container = null;<br/>
        this.digits = [];<br/>
        this.achievement = false;<br/>
        this.defaultString = '';<br/>
        this.flashTimer = 0;<br/>
        this.flashIterations = 0;<br/>
        this.invertTrigger = false;<br/>
        this.flashingRafId = null;<br/>
        this.highScoreBounds = {};<br/>
        this.highScoreFlashing = false;<br/>
        this.config = DistanceMeter.config;<br/>
        this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;<br/>
        this.canvasWidth = canvasWidth;<br/>
        this.init(canvasWidth);<br/>
    }<br/>
    /**<br/>
     * Initialise the distance meter to '00000'.<br/>
     * @param {number} width Canvas width in px.<br/>
     */<br/>
    init(width) {<br/>
        let maxDistanceStr = '';<br/>
        this.calcXPos(width);<br/>
        this.maxScore = this.maxScoreUnits;<br/>
        for (let i = 0; i &lt; this.maxScoreUnits; i++) {<br/>
            this.draw(i, 0);<br/>
            this.defaultString += '0';<br/>
            maxDistanceStr += '9';<br/>
        }<br/>
        this.maxScore = parseInt(maxDistanceStr, 10);<br/>
    }<br/>
    /**<br/>
     * Calculate the xPos in the canvas.<br/>
     * @param {number} canvasWidth<br/>
     */<br/>
    calcXPos(canvasWidth) {<br/>
        this.x = canvasWidth -<br/>
            (DistanceMeter.dimensions.DEST_WIDTH * (this.maxScoreUnits + 1));<br/>
    }<br/>
    /**<br/>
     * Draw a digit to canvas.<br/>
     * @param {number} digitPos Position of the digit.<br/>
     * @param {number} value Digit value 0-9.<br/>
     * @param {boolean=} opt_highScore Whether drawing the high score.<br/>
     */<br/>
    draw(digitPos, value, opt_highScore) {<br/>
        let sourceWidth = DistanceMeter.dimensions.WIDTH;<br/>
        let sourceHeight = DistanceMeter.dimensions.HEIGHT;<br/>
        let sourceX = DistanceMeter.dimensions.WIDTH * value;<br/>
        let sourceY = 0;<br/>
        const targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;<br/>
        const targetY = this.y;<br/>
        const targetWidth = DistanceMeter.dimensions.WIDTH;<br/>
        const targetHeight = DistanceMeter.dimensions.HEIGHT;<br/>
        // For high DPI we 2x source values.<br/>
        if (IS_HIDPI) {<br/>
            sourceWidth *= 2;<br/>
            sourceHeight *= 2;<br/>
            sourceX *= 2;<br/>
        }<br/>
        sourceX += this.spritePos.x;<br/>
        sourceY += this.spritePos.y;<br/>
        this.canvasCtx.save();<br/>
        if (IS_RTL) {<br/>
            if (opt_highScore) {<br/>
                this.canvasCtx.translate(this.canvasWidth -<br/>
                    (DistanceMeter.dimensions.WIDTH * (this.maxScoreUnits + 3)), this.y);<br/>
            }<br/>
            else {<br/>
                this.canvasCtx.translate(this.canvasWidth - DistanceMeter.dimensions.WIDTH, this.y);<br/>
            }<br/>
            this.canvasCtx.scale(-1, 1);<br/>
        }<br/>
        else {<br/>
            const highScoreX = this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH;<br/>
            if (opt_highScore) {<br/>
                this.canvasCtx.translate(highScoreX, this.y);<br/>
            }<br/>
            else {<br/>
                this.canvasCtx.translate(this.x, this.y);<br/>
            }<br/>
        }<br/>
        this.canvasCtx.drawImage(this.image, sourceX, sourceY, sourceWidth, sourceHeight, targetX, targetY, targetWidth, targetHeight);<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    /**<br/>
     * Covert pixel distance to a 'real' distance.<br/>
     * @param {number} distance Pixel distance ran.<br/>
     * @return {number} The 'real' distance ran.<br/>
     */<br/>
    getActualDistance(distance) {<br/>
        return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;<br/>
    }<br/>
    /**<br/>
     * Update the distance meter.<br/>
     * @param {number} distance<br/>
     * @param {number} deltaTime<br/>
     * @return {boolean} Whether the achievement sound fx should be played.<br/>
     */<br/>
    update(deltaTime, distance) {<br/>
        let paint = true;<br/>
        let playSound = false;<br/>
        if (!this.achievement) {<br/>
            distance = this.getActualDistance(distance);<br/>
            // Score has gone beyond the initial digit count.<br/>
            if (distance &gt; this.maxScore &&<br/>
                this.maxScoreUnits === this.config.MAX_DISTANCE_UNITS) {<br/>
                this.maxScoreUnits++;<br/>
                this.maxScore = parseInt(this.maxScore + '9', 10);<br/>
            }<br/>
            else {<br/>
                this.distance = 0;<br/>
            }<br/>
            if (distance &gt; 0) {<br/>
                // Achievement unlocked.<br/>
                if (distance % this.config.ACHIEVEMENT_DISTANCE === 0) {<br/>
                    // Flash score and play sound.<br/>
                    this.achievement = true;<br/>
                    this.flashTimer = 0;<br/>
                    playSound = true;<br/>
                }<br/>
                // Create a string representation of the distance with leading 0.<br/>
                const distanceStr = (this.defaultString + distance).substr(-this.maxScoreUnits);<br/>
                this.digits = distanceStr.split('');<br/>
            }<br/>
            else {<br/>
                this.digits = this.defaultString.split('');<br/>
            }<br/>
        }<br/>
        else {<br/>
            // Control flashing of the score on reaching achievement.<br/>
            if (this.flashIterations &lt;= this.config.FLASH_ITERATIONS) {<br/>
                this.flashTimer += deltaTime;<br/>
                if (this.flashTimer &lt; this.config.FLASH_DURATION) {<br/>
                    paint = false;<br/>
                }<br/>
                else if (this.flashTimer &gt; this.config.FLASH_DURATION * 2) {<br/>
                    this.flashTimer = 0;<br/>
                    this.flashIterations++;<br/>
                }<br/>
            }<br/>
            else {<br/>
                this.achievement = false;<br/>
                this.flashIterations = 0;<br/>
                this.flashTimer = 0;<br/>
            }<br/>
        }<br/>
        // Draw the digits if not flashing.<br/>
        if (paint) {<br/>
            for (let i = this.digits.length - 1; i &gt;= 0; i--) {<br/>
                this.draw(i, parseInt(this.digits[i], 10));<br/>
            }<br/>
        }<br/>
        this.drawHighScore();<br/>
        return playSound;<br/>
    }<br/>
    /**<br/>
     * Draw the high score.<br/>
     */<br/>
    drawHighScore() {<br/>
        if (parseInt(this.highScore, 10) &gt; 0) {<br/>
            this.canvasCtx.save();<br/>
            this.canvasCtx.globalAlpha = .8;<br/>
            for (let i = this.highScore.length - 1; i &gt;= 0; i--) {<br/>
                this.draw(i, parseInt(this.highScore[i], 10), true);<br/>
            }<br/>
            this.canvasCtx.restore();<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Set the highscore as a array string.<br/>
     * Position of char in the sprite: H - 10, I - 11.<br/>
     * @param {number} distance Distance ran in pixels.<br/>
     */<br/>
    setHighScore(distance) {<br/>
        distance = this.getActualDistance(distance);<br/>
        const highScoreStr = (this.defaultString + distance).substr(-this.maxScoreUnits);<br/>
        this.highScore = ['10', '11', ''].concat(highScoreStr.split(''));<br/>
    }<br/>
    /**<br/>
     * Whether a clicked is in the high score area.<br/>
     * @param {Event} e Event object.<br/>
     * @return {boolean} Whether the click was in the high score bounds.<br/>
     */<br/>
    hasClickedOnHighScore(e) {<br/>
        let x = 0;<br/>
        let y = 0;<br/>
        if (e.touches) {<br/>
            // Bounds for touch differ from pointer.<br/>
            const canvasBounds = this.canvas.getBoundingClientRect();<br/>
            x = e.touches[0].clientX - canvasBounds.left;<br/>
            y = e.touches[0].clientY - canvasBounds.top;<br/>
        }<br/>
        else {<br/>
            x = e.offsetX;<br/>
            y = e.offsetY;<br/>
        }<br/>
        this.highScoreBounds = this.getHighScoreBounds();<br/>
        return x &gt;= this.highScoreBounds.x &&<br/>
            x &lt;= this.highScoreBounds.x + this.highScoreBounds.width &&<br/>
            y &gt;= this.highScoreBounds.y &&<br/>
            y &lt;= this.highScoreBounds.y + this.highScoreBounds.height;<br/>
    }<br/>
    /**<br/>
     * Get the bounding box for the high score.<br/>
     * @return {Object} Object with x, y, width and height properties.<br/>
     */<br/>
    getHighScoreBounds() {<br/>
        return {<br/>
            x: (this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH) -<br/>
                DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,<br/>
            y: this.y,<br/>
            width: DistanceMeter.dimensions.WIDTH * (this.highScore.length + 1) +<br/>
                DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,<br/>
            height: DistanceMeter.dimensions.HEIGHT +<br/>
                (DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING * 2),<br/>
        };<br/>
    }<br/>
    /**<br/>
     * Animate flashing the high score to indicate ready for resetting.<br/>
     * The flashing stops following this.config.FLASH_ITERATIONS x 2 flashes.<br/>
     */<br/>
    flashHighScore() {<br/>
        const now = getTimeStamp();<br/>
        const deltaTime = now - (this.frameTimeStamp || now);<br/>
        let paint = true;<br/>
        this.frameTimeStamp = now;<br/>
        // Reached the max number of flashes.<br/>
        if (this.flashIterations &gt; this.config.FLASH_ITERATIONS * 2) {<br/>
            this.cancelHighScoreFlashing();<br/>
            return;<br/>
        }<br/>
        this.flashTimer += deltaTime;<br/>
        if (this.flashTimer &lt; this.config.FLASH_DURATION) {<br/>
            paint = false;<br/>
        }<br/>
        else if (this.flashTimer &gt; this.config.FLASH_DURATION * 2) {<br/>
            this.flashTimer = 0;<br/>
            this.flashIterations++;<br/>
        }<br/>
        if (paint) {<br/>
            this.drawHighScore();<br/>
        }<br/>
        else {<br/>
            this.clearHighScoreBounds();<br/>
        }<br/>
        // Frame update.<br/>
        this.flashingRafId = requestAnimationFrame(this.flashHighScore.bind(this));<br/>
    }<br/>
    /**<br/>
     * Draw empty rectangle over high score.<br/>
     */<br/>
    clearHighScoreBounds() {<br/>
        this.canvasCtx.save();<br/>
        this.canvasCtx.fillStyle = '#fff';<br/>
        this.canvasCtx.rect(this.highScoreBounds.x, this.highScoreBounds.y, this.highScoreBounds.width, this.highScoreBounds.height);<br/>
        this.canvasCtx.fill();<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    /**<br/>
     * Starts the flashing of the high score.<br/>
     */<br/>
    startHighScoreFlashing() {<br/>
        this.highScoreFlashing = true;<br/>
        this.flashHighScore();<br/>
    }<br/>
    /**<br/>
     * Whether high score is flashing.<br/>
     * @return {boolean}<br/>
     */<br/>
    isHighScoreFlashing() {<br/>
        return this.highScoreFlashing;<br/>
    }<br/>
    /**<br/>
     * Stop flashing the high score.<br/>
     */<br/>
    cancelHighScoreFlashing() {<br/>
        if (this.flashingRafId) {<br/>
            cancelAnimationFrame(this.flashingRafId);<br/>
        }<br/>
        this.flashIterations = 0;<br/>
        this.flashTimer = 0;<br/>
        this.highScoreFlashing = false;<br/>
        this.clearHighScoreBounds();<br/>
        this.drawHighScore();<br/>
    }<br/>
    /**<br/>
     * Clear the high score.<br/>
     */<br/>
    resetHighScore() {<br/>
        this.setHighScore(0);<br/>
        this.cancelHighScoreFlashing();<br/>
    }<br/>
    /**<br/>
     * Reset the distance meter back to '00000'.<br/>
     */<br/>
    reset() {<br/>
        this.update(0, 0);<br/>
        this.achievement = false;<br/>
    }<br/>
}<br/>
/**<br/>
 * @enum {number}<br/>
 */<br/>
DistanceMeter.dimensions = {<br/>
    WIDTH: 10,<br/>
    HEIGHT: 13,<br/>
    DEST_WIDTH: 11,<br/>
};<br/>
/**<br/>
 * Y positioning of the digits in the sprite sheet.<br/>
 * X position is always 0.<br/>
 * @type {Array&lt;number&gt;}<br/>
 */<br/>
DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];<br/>
/**<br/>
 * Distance meter config.<br/>
 * @enum {number}<br/>
 */<br/>
DistanceMeter.config = {<br/>
    // Number of digits.<br/>
    MAX_DISTANCE_UNITS: 5,<br/>
    // Distance that causes achievement animation.<br/>
    ACHIEVEMENT_DISTANCE: 100,<br/>
    // Used for conversion from pixel distance to a scaled unit.<br/>
    COEFFICIENT: 0.025,<br/>
    // Flash duration in milliseconds.<br/>
    FLASH_DURATION: 1000 / 4,<br/>
    // Flash iterations for achievement animation.<br/>
    FLASH_ITERATIONS: 3,<br/>
    // Padding around the high score hit area.<br/>
    HIGH_SCORE_HIT_AREA_PADDING: 4,<br/>
};<br/>
<br/>
// Copyright 2021 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/* @const<br/>
 * Add matching sprite definition and config to spriteDefinitionByType.<br/>
 */<br/>
const GAME_TYPE = ['altgame'];<br/>
//******************************************************************************<br/>
/**<br/>
 * Collision box object.<br/>
 * @param {number} x X position.<br/>
 * @param {number} y Y Position.<br/>
 * @param {number} w Width.<br/>
 * @param {number} h Height.<br/>
 * @constructor<br/>
 */<br/>
function CollisionBox(x, y, w, h) {<br/>
    this.x = x;<br/>
    this.y = y;<br/>
    this.width = w;<br/>
    this.height = h;<br/>
}<br/>
/**<br/>
 * T-Rex runner sprite definitions.<br/>
 */<br/>
const spriteDefinitionByType = {<br/>
    original: {<br/>
        LDPI: {<br/>
            BACKGROUND_EL: { x: 86, y: 2 },<br/>
            CACTUS_LARGE: { x: 332, y: 2 },<br/>
            CACTUS_SMALL: { x: 228, y: 2 },<br/>
            OBSTACLE_2: { x: 332, y: 2 },<br/>
            OBSTACLE: { x: 228, y: 2 },<br/>
            CLOUD: { x: 86, y: 2 },<br/>
            HORIZON: { x: 2, y: 54 },<br/>
            MOON: { x: 484, y: 2 },<br/>
            PTERODACTYL: { x: 134, y: 2 },<br/>
            RESTART: { x: 2, y: 68 },<br/>
            TEXT_SPRITE: { x: 655, y: 2 },<br/>
            TREX: { x: 848, y: 2 },<br/>
            STAR: { x: 645, y: 2 },<br/>
            COLLECTABLE: { x: 0, y: 0 },<br/>
            ALT_GAME_END: { x: 32, y: 0 },<br/>
        },<br/>
        HDPI: {<br/>
            BACKGROUND_EL: { x: 166, y: 2 },<br/>
            CACTUS_LARGE: { x: 652, y: 2 },<br/>
            CACTUS_SMALL: { x: 446, y: 2 },<br/>
            OBSTACLE_2: { x: 652, y: 2 },<br/>
            OBSTACLE: { x: 446, y: 2 },<br/>
            CLOUD: { x: 166, y: 2 },<br/>
            HORIZON: { x: 2, y: 104 },<br/>
            MOON: { x: 954, y: 2 },<br/>
            PTERODACTYL: { x: 260, y: 2 },<br/>
            RESTART: { x: 2, y: 130 },<br/>
            TEXT_SPRITE: { x: 1294, y: 2 },<br/>
            TREX: { x: 1678, y: 2 },<br/>
            STAR: { x: 1276, y: 2 },<br/>
            COLLECTABLE: { x: 0, y: 0 },<br/>
            ALT_GAME_END: { x: 64, y: 0 },<br/>
        },<br/>
        MAX_GAP_COEFFICIENT: 1.5,<br/>
        MAX_OBSTACLE_LENGTH: 3,<br/>
        HAS_CLOUDS: 1,<br/>
        BOTTOM_PAD: 10,<br/>
        TREX: {<br/>
            WAITING_1: { x: 44, w: 44, h: 47, xOffset: 0 },<br/>
            WAITING_2: { x: 0, w: 44, h: 47, xOffset: 0 },<br/>
            RUNNING_1: { x: 88, w: 44, h: 47, xOffset: 0 },<br/>
            RUNNING_2: { x: 132, w: 44, h: 47, xOffset: 0 },<br/>
            JUMPING: { x: 0, w: 44, h: 47, xOffset: 0 },<br/>
            CRASHED: { x: 220, w: 44, h: 47, xOffset: 0 },<br/>
            COLLISION_BOXES: [<br/>
                new CollisionBox(22, 0, 17, 16),<br/>
                new CollisionBox(1, 18, 30, 9),<br/>
                new CollisionBox(10, 35, 14, 8),<br/>
                new CollisionBox(1, 24, 29, 5),<br/>
                new CollisionBox(5, 30, 21, 4),<br/>
                new CollisionBox(9, 34, 15, 4),<br/>
            ],<br/>
        },<br/>
        /** @type {Array&lt;ObstacleType&gt;} */<br/>
        OBSTACLES: [<br/>
            {<br/>
                type: 'CACTUS_SMALL',<br/>
                width: 17,<br/>
                height: 35,<br/>
                yPos: 105,<br/>
                multipleSpeed: 4,<br/>
                minGap: 120,<br/>
                minSpeed: 0,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 7, 5, 27),<br/>
                    new CollisionBox(4, 0, 6, 34),<br/>
                    new CollisionBox(10, 4, 7, 14),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'CACTUS_LARGE',<br/>
                width: 25,<br/>
                height: 50,<br/>
                yPos: 90,<br/>
                multipleSpeed: 7,<br/>
                minGap: 120,<br/>
                minSpeed: 0,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 12, 7, 38),<br/>
                    new CollisionBox(8, 0, 7, 49),<br/>
                    new CollisionBox(13, 10, 10, 38),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'PTERODACTYL',<br/>
                width: 46,<br/>
                height: 40,<br/>
                yPos: [100, 75, 50], // Variable height.<br/>
                yPosMobile: [100, 50], // Variable height mobile.<br/>
                multipleSpeed: 999,<br/>
                minSpeed: 8.5,<br/>
                minGap: 150,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(15, 15, 16, 5),<br/>
                    new CollisionBox(18, 21, 24, 6),<br/>
                    new CollisionBox(2, 14, 4, 3),<br/>
                    new CollisionBox(6, 10, 4, 7),<br/>
                    new CollisionBox(10, 8, 6, 9),<br/>
                ],<br/>
                numFrames: 2,<br/>
                frameRate: 1000 / 6,<br/>
                speedOffset: .8,<br/>
            },<br/>
            {<br/>
                type: 'COLLECTABLE',<br/>
                width: 31,<br/>
                height: 24,<br/>
                yPos: 104,<br/>
                multipleSpeed: 1000,<br/>
                minGap: 9999,<br/>
                minSpeed: 0,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 0, 32, 25),<br/>
                ],<br/>
            },<br/>
        ],<br/>
        BACKGROUND_EL: {<br/>
            'CLOUD': {<br/>
                HEIGHT: 14,<br/>
                MAX_CLOUD_GAP: 400,<br/>
                MAX_SKY_LEVEL: 30,<br/>
                MIN_CLOUD_GAP: 100,<br/>
                MIN_SKY_LEVEL: 71,<br/>
                OFFSET: 4,<br/>
                WIDTH: 46,<br/>
                X_POS: 1,<br/>
                Y_POS: 120,<br/>
            },<br/>
        },<br/>
        BACKGROUND_EL_CONFIG: {<br/>
            MAX_BG_ELS: 1,<br/>
            MAX_GAP: 400,<br/>
            MIN_GAP: 100,<br/>
            POS: 0,<br/>
            SPEED: 0.5,<br/>
            Y_POS: 125,<br/>
        },<br/>
        LINES: [<br/>
            { SOURCE_X: 2, SOURCE_Y: 52, WIDTH: 600, HEIGHT: 12, YPOS: 127 },<br/>
        ],<br/>
        ALT_GAME_OVER_TEXT_CONFIG: {<br/>
            TEXT_X: 32,<br/>
            TEXT_Y: 0,<br/>
            TEXT_WIDTH: 246,<br/>
            TEXT_HEIGHT: 17,<br/>
            FLASH_DURATION: 1500,<br/>
            FLASHING: false,<br/>
        },<br/>
    },<br/>
    altgame: {<br/>
        LDPI: {<br/>
            BACKGROUND_EL: { x: 260, y: 19 },<br/>
            OBSTACLE1: { x: 152, y: 65 },<br/>
            OBSTACLE2: { x: 188, y: 65 },<br/>
            OBSTACLE3: { x: 152, y: 65 },<br/>
            OBSTACLE4: { x: 188, y: 65 },<br/>
            OBSTACLE5: { x: 0, y: 60 },<br/>
            OBSTACLE6: { x: 42, y: 58 },<br/>
            OBSTACLE7: { x: 98, y: 58 },<br/>
            OBSTACLE8: { x: 96, y: 19 },<br/>
            HORIZON: { x: 0, y: 3 },<br/>
            TREX: { x: 557, y: 63 },<br/>
            COLLECTABLE: { x: 193, y: 19 },<br/>
        },<br/>
        HDPI: {<br/>
            BACKGROUND_EL: { x: 520, y: 38 },<br/>
            OBSTACLE1: { x: 304, y: 130 },<br/>
            OBSTACLE2: { x: 376, y: 130 },<br/>
            OBSTACLE3: { x: 304, y: 130 },<br/>
            OBSTACLE4: { x: 376, y: 130 },<br/>
            OBSTACLE5: { x: 0, y: 120 },<br/>
            OBSTACLE6: { x: 84, y: 116 },<br/>
            OBSTACLE7: { x: 196, y: 116 },<br/>
            OBSTACLE8: { x: 192, y: 38 },<br/>
            HORIZON: { x: 0, y: 6 },<br/>
            TREX: { x: 1114, y: 126 },<br/>
            COLLECTABLE: { x: 386, y: 38 },<br/>
        },<br/>
        MAX_GAP_COEFFICIENT: 1.5,<br/>
        MAX_OBSTACLE_LENGTH: 2,<br/>
        HAS_CLOUDS: 0,<br/>
        BOTTOM_PAD: 10,<br/>
        TREX: {<br/>
            MAX_JUMP_HEIGHT: 50,<br/>
            MIN_JUMP_HEIGHT: 40,<br/>
            INITIAL_JUMP_VELOCITY: -10,<br/>
            RUNNING_1: { x: 96, w: 49, h: 47, xOffset: 0 },<br/>
            RUNNING_2: { x: 145, w: 49, h: 47, xOffset: 0 },<br/>
            JUMPING: { x: 47, w: 49, h: 47, xOffset: 0 },<br/>
            CRASHED: { x: 194, w: 61, h: 47, xOffset: 0 },<br/>
            DUCKING_1: { x: 257, w: 55, h: 26, xOffset: 0 },<br/>
            DUCKING_2: { x: 316, w: 55, h: 26, xOffset: 0 },<br/>
            COLLISION_BOXES: [<br/>
                new CollisionBox(22, 0, 17, 16),<br/>
                new CollisionBox(1, 18, 30, 9),<br/>
                new CollisionBox(10, 35, 14, 8),<br/>
                new CollisionBox(1, 24, 29, 5),<br/>
                new CollisionBox(5, 30, 21, 4),<br/>
                new CollisionBox(9, 34, 15, 4),<br/>
            ],<br/>
        },<br/>
        /** @type {Array&lt;ObstacleType&gt;} */<br/>
        OBSTACLES: [<br/>
            {<br/>
                type: 'OBSTACLE1',<br/>
                width: 36,<br/>
                height: 45,<br/>
                yPos: 95,<br/>
                multipleSpeed: 999,<br/>
                minGap: 120,<br/>
                minSpeed: 0,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 17, 8, 28),<br/>
                    new CollisionBox(6, 3, 24, 42),<br/>
                    new CollisionBox(28, 17, 8, 28),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'OBSTACLE2',<br/>
                width: 36,<br/>
                height: 45,<br/>
                yPos: 95,<br/>
                multipleSpeed: 999,<br/>
                minGap: 120,<br/>
                minSpeed: 0,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 17, 8, 28),<br/>
                    new CollisionBox(6, 3, 24, 42),<br/>
                    new CollisionBox(28, 17, 8, 28),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'OBSTACLE3',<br/>
                width: 72,<br/>
                height: 45,<br/>
                yPos: 95,<br/>
                multipleSpeed: 999,<br/>
                minGap: 120,<br/>
                minSpeed: 8,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 17, 8, 28),<br/>
                    new CollisionBox(6, 3, 24, 42),<br/>
                    new CollisionBox(28, 17, 8, 28),<br/>
                    new CollisionBox(36, 17, 8, 28),<br/>
                    new CollisionBox(42, 3, 24, 42),<br/>
                    new CollisionBox(64, 17, 8, 28),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'OBSTACLE4',<br/>
                width: 72,<br/>
                height: 45,<br/>
                yPos: 95,<br/>
                multipleSpeed: 999,<br/>
                minGap: 120,<br/>
                minSpeed: 8,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 17, 8, 28),<br/>
                    new CollisionBox(6, 3, 24, 42),<br/>
                    new CollisionBox(28, 17, 8, 28),<br/>
                    new CollisionBox(36, 17, 8, 28),<br/>
                    new CollisionBox(42, 3, 24, 42),<br/>
                    new CollisionBox(64, 17, 8, 28),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'OBSTACLE5',<br/>
                width: 42,<br/>
                height: 50,<br/>
                yPos: 95,<br/>
                multipleSpeed: 999,<br/>
                minGap: 120,<br/>
                minSpeed: 5,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 0, 42, 50),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'OBSTACLE6',<br/>
                width: 56,<br/>
                height: 52,<br/>
                yPos: 93,<br/>
                multipleSpeed: 999,<br/>
                minGap: 120,<br/>
                minSpeed: 7,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 11, 8, 40),<br/>
                    new CollisionBox(8, 0, 19, 51),<br/>
                    new CollisionBox(27, 11, 28, 40),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'OBSTACLE7',<br/>
                width: 54,<br/>
                height: 52,<br/>
                yPos: 93,<br/>
                multipleSpeed: 999,<br/>
                minGap: 120,<br/>
                minSpeed: 6,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(0, 11, 19, 40),<br/>
                    new CollisionBox(19, 0, 19, 51),<br/>
                    new CollisionBox(38, 14, 15, 37),<br/>
                ],<br/>
            },<br/>
            {<br/>
                type: 'OBSTACLE8',<br/>
                width: 49,<br/>
                height: 20,<br/>
                yPos: [100, 75, 50], // Variable height.<br/>
                yPosMobile: [100, 50], // Variable height mobile.<br/>
                multipleSpeed: 999,<br/>
                minSpeed: 8.5,<br/>
                minGap: 150,<br/>
                collisionBoxes: [<br/>
                    new CollisionBox(15, 15, 16, 5),<br/>
                    new CollisionBox(18, 21, 24, 6),<br/>
                    new CollisionBox(2, 14, 4, 3),<br/>
                    new CollisionBox(6, 10, 4, 7),<br/>
                    new CollisionBox(10, 8, 6, 9),<br/>
                ],<br/>
                numFrames: 2,<br/>
                frameRate: 1000 / 6,<br/>
                speedOffset: .8,<br/>
            },<br/>
        ],<br/>
        BACKGROUND_EL: {<br/>
            'GROUP1': {<br/>
                HEIGHT: 91,<br/>
                MAX_CLOUD_GAP: 600,<br/>
                MAX_SKY_LEVEL: 0,<br/>
                MIN_CLOUD_GAP: 300,<br/>
                MIN_SKY_LEVEL: 0,<br/>
                OFFSET: 11,<br/>
                WIDTH: 131,<br/>
                X_POS: 260,<br/>
            },<br/>
            'GROUP2': {<br/>
                HEIGHT: 91,<br/>
                MAX_CLOUD_GAP: 600,<br/>
                MAX_SKY_LEVEL: 0,<br/>
                MIN_CLOUD_GAP: 300,<br/>
                MIN_SKY_LEVEL: 0,<br/>
                OFFSET: 11,<br/>
                WIDTH: 166,<br/>
                X_POS: 391,<br/>
            },<br/>
        },<br/>
        BACKGROUND_EL_CONFIG: {<br/>
            MAX_BG_ELS: 8,<br/>
            MAX_GAP: 600,<br/>
            MIN_GAP: 300,<br/>
            POS: 0,<br/>
            SPEED: 0.8,<br/>
            Y_POS: 122,<br/>
        },<br/>
        LINES: [<br/>
            { SOURCE_X: 2, SOURCE_Y: 3, WIDTH: 600, HEIGHT: 12, YPOS: 128 },<br/>
        ],<br/>
    },<br/>
};<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class Trex {<br/>
    /**<br/>
     * T-rex game character.<br/>
     * @param {HTMLCanvasElement} canvas<br/>
     * @param {Object} spritePos Positioning within image sprite.<br/>
     */<br/>
    constructor(canvas, spritePos) {<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));<br/>
        this.spritePos = spritePos;<br/>
        this.xPos = 0;<br/>
        this.yPos = 0;<br/>
        this.xInitialPos = 0;<br/>
        // Position when on the ground.<br/>
        this.groundYPos = 0;<br/>
        this.currentFrame = 0;<br/>
        this.currentAnimFrames = [];<br/>
        this.blinkDelay = 0;<br/>
        this.blinkCount = 0;<br/>
        this.animStartTime = 0;<br/>
        this.timer = 0;<br/>
        this.msPerFrame = 1000 / FPS;<br/>
        this.config = Object.assign(Trex.config, Trex.normalJumpConfig);<br/>
        // Current status.<br/>
        this.status = Trex.status.WAITING;<br/>
        this.jumping = false;<br/>
        this.ducking = false;<br/>
        this.jumpVelocity = 0;<br/>
        this.reachedMinHeight = false;<br/>
        this.speedDrop = false;<br/>
        this.jumpCount = 0;<br/>
        this.jumpspotX = 0;<br/>
        this.altGameModeEnabled = false;<br/>
        this.flashing = false;<br/>
        this.init();<br/>
    }<br/>
    /**<br/>
     * T-rex player initialiser.<br/>
     * Sets the t-rex to blink at random intervals.<br/>
     */<br/>
    init() {<br/>
        this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -<br/>
            Runner.config.BOTTOM_PAD;<br/>
        this.yPos = this.groundYPos;<br/>
        this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;<br/>
        this.draw(0, 0);<br/>
        this.update(0, Trex.status.WAITING);<br/>
    }<br/>
    /**<br/>
     * Assign the appropriate jump parameters based on the game speed.<br/>
     */<br/>
    enableSlowConfig() {<br/>
        const jumpConfig = Runner.slowDown ? Trex.slowJumpConfig : Trex.normalJumpConfig;<br/>
        Trex.config = Object.assign(Trex.config, jumpConfig);<br/>
        this.adjustAltGameConfigForSlowSpeed();<br/>
    }<br/>
    /**<br/>
     * Enables the alternative game. Redefines the dino config.<br/>
     * @param {Object} spritePos New positioning within image sprite.<br/>
     */<br/>
    enableAltGameMode(spritePos) {<br/>
        this.altGameModeEnabled = true;<br/>
        this.spritePos = spritePos;<br/>
        const spriteDefinition = Runner.spriteDefinition['TREX'];<br/>
        // Update animation frames.<br/>
        Trex.animFrames.RUNNING.frames =<br/>
            [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x];<br/>
        Trex.animFrames.CRASHED.frames = [spriteDefinition.CRASHED.x];<br/>
        if (typeof spriteDefinition.JUMPING.x === 'object') {<br/>
            Trex.animFrames.JUMPING.frames = spriteDefinition.JUMPING.x;<br/>
        }<br/>
        else {<br/>
            Trex.animFrames.JUMPING.frames = [spriteDefinition.JUMPING.x];<br/>
        }<br/>
        Trex.animFrames.DUCKING.frames =<br/>
            [spriteDefinition.DUCKING_1.x, spriteDefinition.DUCKING_2.x];<br/>
        // Update Trex config<br/>
        Trex.config.GRAVITY = spriteDefinition.GRAVITY || Trex.config.GRAVITY;<br/>
        Trex.config.HEIGHT = spriteDefinition.RUNNING_1.h,<br/>
            Trex.config.INITIAL_JUMP_VELOCITY = spriteDefinition.INITIAL_JUMP_VELOCITY;<br/>
        Trex.config.MAX_JUMP_HEIGHT = spriteDefinition.MAX_JUMP_HEIGHT;<br/>
        Trex.config.MIN_JUMP_HEIGHT = spriteDefinition.MIN_JUMP_HEIGHT;<br/>
        Trex.config.WIDTH = spriteDefinition.RUNNING_1.w;<br/>
        Trex.config.WIDTH_CRASHED = spriteDefinition.CRASHED.w;<br/>
        Trex.config.WIDTH_JUMP = spriteDefinition.JUMPING.w;<br/>
        Trex.config.INVERT_JUMP = spriteDefinition.INVERT_JUMP;<br/>
        this.adjustAltGameConfigForSlowSpeed(spriteDefinition.GRAVITY);<br/>
        this.config = Trex.config;<br/>
        // Adjust bottom horizon placement.<br/>
        this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -<br/>
            Runner.spriteDefinition['BOTTOM_PAD'];<br/>
        this.yPos = this.groundYPos;<br/>
        this.reset();<br/>
    }<br/>
    /**<br/>
     * Slow speeds adjustments for the alt game modes.<br/>
     * @param {number=} opt_gravityValue<br/>
     */<br/>
    adjustAltGameConfigForSlowSpeed(opt_gravityValue) {<br/>
        if (Runner.slowDown) {<br/>
            if (opt_gravityValue) {<br/>
                Trex.config.GRAVITY = opt_gravityValue / 1.5;<br/>
            }<br/>
            Trex.config.MIN_JUMP_HEIGHT *= 1.5;<br/>
            Trex.config.MAX_JUMP_HEIGHT *= 1.5;<br/>
            Trex.config.INITIAL_JUMP_VELOCITY =<br/>
                Trex.config.INITIAL_JUMP_VELOCITY * 1.5;<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Setter whether dino is flashing.<br/>
     * @param {boolean} status<br/>
     */<br/>
    setFlashing(status) {<br/>
        this.flashing = status;<br/>
    }<br/>
    /**<br/>
     * Setter for the jump velocity.<br/>
     * The appropriate drop velocity is also set.<br/>
     * @param {number} setting<br/>
     */<br/>
    setJumpVelocity(setting) {<br/>
        this.config.INITIAL_JUMP_VELOCITY = -setting;<br/>
        this.config.DROP_VELOCITY = -setting / 2;<br/>
    }<br/>
    /**<br/>
     * Set the animation status.<br/>
     * @param {!number} deltaTime<br/>
     * @param {Trex.status=} opt_status Optional status to switch to.<br/>
     */<br/>
    update(deltaTime, opt_status) {<br/>
        this.timer += deltaTime;<br/>
        // Update the status.<br/>
        if (opt_status) {<br/>
            this.status = opt_status;<br/>
            this.currentFrame = 0;<br/>
            this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;<br/>
            this.currentAnimFrames = Trex.animFrames[opt_status].frames;<br/>
            if (opt_status === Trex.status.WAITING) {<br/>
                this.animStartTime = getTimeStamp();<br/>
                this.setBlinkDelay();<br/>
            }<br/>
        }<br/>
        // Game intro animation, T-rex moves in from the left.<br/>
        if (this.playingIntro && this.xPos &lt; this.config.START_X_POS) {<br/>
            this.xPos += Math.round((this.config.START_X_POS / this.config.INTRO_DURATION) * deltaTime);<br/>
            this.xInitialPos = this.xPos;<br/>
        }<br/>
        if (this.status === Trex.status.WAITING) {<br/>
            this.blink(getTimeStamp());<br/>
        }<br/>
        else {<br/>
            this.draw(this.currentAnimFrames[this.currentFrame], 0);<br/>
        }<br/>
        // Update the frame position.<br/>
        if (!this.flashing && this.timer &gt;= this.msPerFrame) {<br/>
            this.currentFrame =<br/>
                this.currentFrame === this.currentAnimFrames.length - 1 ?<br/>
                    0 :<br/>
                    this.currentFrame + 1;<br/>
            this.timer = 0;<br/>
        }<br/>
        // Speed drop becomes duck if the down key is still being pressed.<br/>
        if (this.speedDrop && this.yPos === this.groundYPos) {<br/>
            this.speedDrop = false;<br/>
            this.setDuck(true);<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Draw the t-rex to a particular position.<br/>
     * @param {number} x<br/>
     * @param {number} y<br/>
     */<br/>
    draw(x, y) {<br/>
        let sourceX = x;<br/>
        let sourceY = y;<br/>
        let sourceWidth = this.ducking && this.status !== Trex.status.CRASHED ?<br/>
            this.config.WIDTH_DUCK :<br/>
            this.config.WIDTH;<br/>
        let sourceHeight = this.config.HEIGHT;<br/>
        const outputHeight = sourceHeight;<br/>
        const outputWidth = this.altGameModeEnabled && this.status === Trex.status.CRASHED ?<br/>
            this.config.WIDTH_CRASHED :<br/>
            this.config.WIDTH;<br/>
        let jumpOffset = Runner.spriteDefinition.TREX.JUMPING.xOffset;<br/>
        // Width of sprite can change on jump or crashed.<br/>
        if (this.altGameModeEnabled) {<br/>
            if (this.jumping && this.status !== Trex.status.CRASHED) {<br/>
                sourceWidth = this.config.WIDTH_JUMP;<br/>
            }<br/>
            else if (this.status === Trex.status.CRASHED) {<br/>
                sourceWidth = this.config.WIDTH_CRASHED;<br/>
            }<br/>
        }<br/>
        if (IS_HIDPI) {<br/>
            sourceX *= 2;<br/>
            sourceY *= 2;<br/>
            sourceWidth *= 2;<br/>
            sourceHeight *= 2;<br/>
            jumpOffset *= 2;<br/>
        }<br/>
        // Adjustments for sprite sheet position.<br/>
        sourceX += this.spritePos.x;<br/>
        sourceY += this.spritePos.y;<br/>
        // Flashing.<br/>
        if (this.flashing) {<br/>
            if (this.timer &lt; this.config.FLASH_ON) {<br/>
                this.canvasCtx.globalAlpha = 0.5;<br/>
            }<br/>
            else if (this.timer &gt; this.config.FLASH_OFF) {<br/>
                this.timer = 0;<br/>
            }<br/>
        }<br/>
        // Ducking.<br/>
        if (this.ducking && this.status !== Trex.status.CRASHED) {<br/>
            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight, this.xPos, this.yPos, this.config.WIDTH_DUCK, outputHeight);<br/>
        }<br/>
        else if (this.altGameModeEnabled && this.jumping &&<br/>
            this.status !== Trex.status.CRASHED) {<br/>
            // Jumping with adjustments.<br/>
            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight, this.xPos - jumpOffset, this.yPos, this.config.WIDTH_JUMP, outputHeight);<br/>
        }<br/>
        else {<br/>
            // Crashed whilst ducking. Trex is standing up so needs adjustment.<br/>
            if (this.ducking && this.status === Trex.status.CRASHED) {<br/>
                this.xPos++;<br/>
            }<br/>
            // Standing / running<br/>
            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight, this.xPos, this.yPos, outputWidth, outputHeight);<br/>
        }<br/>
        this.canvasCtx.globalAlpha = 1;<br/>
    }<br/>
    /**<br/>
     * Sets a random time for the blink to happen.<br/>
     */<br/>
    setBlinkDelay() {<br/>
        this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);<br/>
    }<br/>
    /**<br/>
     * Make t-rex blink at random intervals.<br/>
     * @param {number} time Current time in milliseconds.<br/>
     */<br/>
    blink(time) {<br/>
        const deltaTime = time - this.animStartTime;<br/>
        if (deltaTime &gt;= this.blinkDelay) {<br/>
            this.draw(this.currentAnimFrames[this.currentFrame], 0);<br/>
            if (this.currentFrame === 1) {<br/>
                // Set new random delay to blink.<br/>
                this.setBlinkDelay();<br/>
                this.animStartTime = time;<br/>
                this.blinkCount++;<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Initialise a jump.<br/>
     * @param {number} speed<br/>
     */<br/>
    startJump(speed) {<br/>
        if (!this.jumping) {<br/>
            this.update(0, Trex.status.JUMPING);<br/>
            // Tweak the jump velocity based on the speed.<br/>
            this.jumpVelocity = this.config.INITIAL_JUMP_VELOCITY - (speed / 10);<br/>
            this.jumping = true;<br/>
            this.reachedMinHeight = false;<br/>
            this.speedDrop = false;<br/>
            if (this.config.INVERT_JUMP) {<br/>
                this.minJumpHeight = this.groundYPos + this.config.MIN_JUMP_HEIGHT;<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Jump is complete, falling down.<br/>
     */<br/>
    endJump() {<br/>
        if (this.reachedMinHeight &&<br/>
            this.jumpVelocity &lt; this.config.DROP_VELOCITY) {<br/>
            this.jumpVelocity = this.config.DROP_VELOCITY;<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Update frame for a jump.<br/>
     * @param {number} deltaTime<br/>
     */<br/>
    updateJump(deltaTime) {<br/>
        const msPerFrame = Trex.animFrames[this.status].msPerFrame;<br/>
        const framesElapsed = deltaTime / msPerFrame;<br/>
        // Speed drop makes Trex fall faster.<br/>
        if (this.speedDrop) {<br/>
            this.yPos += Math.round(this.jumpVelocity * this.config.SPEED_DROP_COEFFICIENT *<br/>
                framesElapsed);<br/>
        }<br/>
        else if (this.config.INVERT_JUMP) {<br/>
            this.yPos -= Math.round(this.jumpVelocity * framesElapsed);<br/>
        }<br/>
        else {<br/>
            this.yPos += Math.round(this.jumpVelocity * framesElapsed);<br/>
        }<br/>
        this.jumpVelocity += this.config.GRAVITY * framesElapsed;<br/>
        // Minimum height has been reached.<br/>
        if (this.config.INVERT_JUMP && (this.yPos &gt; this.minJumpHeight) ||<br/>
            !this.config.INVERT_JUMP && (this.yPos &lt; this.minJumpHeight) ||<br/>
            this.speedDrop) {<br/>
            this.reachedMinHeight = true;<br/>
        }<br/>
        // Reached max height.<br/>
        if (this.config.INVERT_JUMP && (this.yPos &gt; -this.config.MAX_JUMP_HEIGHT) ||<br/>
            !this.config.INVERT_JUMP && (this.yPos &lt; this.config.MAX_JUMP_HEIGHT) ||<br/>
            this.speedDrop) {<br/>
            this.endJump();<br/>
        }<br/>
        // Back down at ground level. Jump completed.<br/>
        if ((this.config.INVERT_JUMP && this.yPos) &lt; this.groundYPos ||<br/>
            (!this.config.INVERT_JUMP && this.yPos) &gt; this.groundYPos) {<br/>
            this.reset();<br/>
            this.jumpCount++;<br/>
            if (Runner.audioCues) {<br/>
                Runner.generatedSoundFx.loopFootSteps();<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Set the speed drop. Immediately cancels the current jump.<br/>
     */<br/>
    setSpeedDrop() {<br/>
        this.speedDrop = true;<br/>
        this.jumpVelocity = 1;<br/>
    }<br/>
    /**<br/>
     * @param {boolean} isDucking<br/>
     */<br/>
    setDuck(isDucking) {<br/>
        if (isDucking && this.status !== Trex.status.DUCKING) {<br/>
            this.update(0, Trex.status.DUCKING);<br/>
            this.ducking = true;<br/>
        }<br/>
        else if (this.status === Trex.status.DUCKING) {<br/>
            this.update(0, Trex.status.RUNNING);<br/>
            this.ducking = false;<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Reset the t-rex to running at start of game.<br/>
     */<br/>
    reset() {<br/>
        this.xPos = this.xInitialPos;<br/>
        this.yPos = this.groundYPos;<br/>
        this.jumpVelocity = 0;<br/>
        this.jumping = false;<br/>
        this.ducking = false;<br/>
        this.update(0, Trex.status.RUNNING);<br/>
        this.midair = false;<br/>
        this.speedDrop = false;<br/>
        this.jumpCount = 0;<br/>
    }<br/>
}<br/>
/**<br/>
 * T-rex player config.<br/>
 */<br/>
Trex.config = {<br/>
    DROP_VELOCITY: -5,<br/>
    FLASH_OFF: 175,<br/>
    FLASH_ON: 100,<br/>
    HEIGHT: 47,<br/>
    HEIGHT_DUCK: 25,<br/>
    INTRO_DURATION: 1500,<br/>
    SPEED_DROP_COEFFICIENT: 3,<br/>
    SPRITE_WIDTH: 262,<br/>
    START_X_POS: 50,<br/>
    WIDTH: 44,<br/>
    WIDTH_DUCK: 59,<br/>
};<br/>
Trex.slowJumpConfig = {<br/>
    GRAVITY: 0.25,<br/>
    MAX_JUMP_HEIGHT: 50,<br/>
    MIN_JUMP_HEIGHT: 45,<br/>
    INITIAL_JUMP_VELOCITY: -20,<br/>
};<br/>
Trex.normalJumpConfig = {<br/>
    GRAVITY: 0.6,<br/>
    MAX_JUMP_HEIGHT: 30,<br/>
    MIN_JUMP_HEIGHT: 30,<br/>
    INITIAL_JUMP_VELOCITY: -10,<br/>
};<br/>
/**<br/>
 * Used in collision detection.<br/>
 * @enum {Array&lt;CollisionBox&gt;}<br/>
 */<br/>
Trex.collisionBoxes = {<br/>
    DUCKING: [new CollisionBox(1, 18, 55, 25)],<br/>
    RUNNING: [<br/>
        new CollisionBox(22, 0, 17, 16),<br/>
        new CollisionBox(1, 18, 30, 9),<br/>
        new CollisionBox(10, 35, 14, 8),<br/>
        new CollisionBox(1, 24, 29, 5),<br/>
        new CollisionBox(5, 30, 21, 4),<br/>
        new CollisionBox(9, 34, 15, 4),<br/>
    ],<br/>
};<br/>
/**<br/>
 * Animation states.<br/>
 * @enum {string}<br/>
 */<br/>
Trex.status = {<br/>
    CRASHED: 'CRASHED',<br/>
    DUCKING: 'DUCKING',<br/>
    JUMPING: 'JUMPING',<br/>
    RUNNING: 'RUNNING',<br/>
    WAITING: 'WAITING',<br/>
};<br/>
/**<br/>
 * Blinking coefficient.<br/>
 * @const<br/>
 */<br/>
Trex.BLINK_TIMING = 7000;<br/>
/**<br/>
 * Animation config for different states.<br/>
 * @enum {Object}<br/>
 */<br/>
Trex.animFrames = {<br/>
    WAITING: {<br/>
        frames: [44, 0],<br/>
        msPerFrame: 1000 / 3,<br/>
    },<br/>
    RUNNING: {<br/>
        frames: [88, 132],<br/>
        msPerFrame: 1000 / 12,<br/>
    },<br/>
    CRASHED: {<br/>
        frames: [220],<br/>
        msPerFrame: 1000 / 60,<br/>
    },<br/>
    JUMPING: {<br/>
        frames: [0],<br/>
        msPerFrame: 1000 / 60,<br/>
    },<br/>
    DUCKING: {<br/>
        frames: [264, 323],<br/>
        msPerFrame: 1000 / 8,<br/>
    },<br/>
};<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class GameOverPanel {<br/>
    /**<br/>
     * Game over panel.<br/>
     * @param {!HTMLCanvasElement} canvas<br/>
     * @param {Object} textImgPos<br/>
     * @param {Object} restartImgPos<br/>
     * @param {!Object} dimensions Canvas dimensions.<br/>
     * @param {Object=} opt_altGameEndImgPos<br/>
     * @param {boolean=} opt_altGameActive<br/>
     */<br/>
    constructor(canvas, textImgPos, restartImgPos, dimensions, opt_altGameEndImgPos, opt_altGameActive) {<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));<br/>
        this.canvasDimensions = dimensions;<br/>
        this.textImgPos = textImgPos;<br/>
        this.restartImgPos = restartImgPos;<br/>
        this.altGameEndImgPos = opt_altGameEndImgPos;<br/>
        this.altGameModeActive = opt_altGameActive;<br/>
        // Retry animation.<br/>
        this.frameTimeStamp = 0;<br/>
        this.animTimer = 0;<br/>
        this.currentFrame = 0;<br/>
        this.gameOverRafId = null;<br/>
        this.flashTimer = 0;<br/>
        this.flashCounter = 0;<br/>
        this.originalText = true;<br/>
    }<br/>
    /**<br/>
     * Update the panel dimensions.<br/>
     * @param {number} width New canvas width.<br/>
     * @param {number} opt_height Optional new canvas height.<br/>
     */<br/>
    updateDimensions(width, opt_height) {<br/>
        this.canvasDimensions.WIDTH = width;<br/>
        if (opt_height) {<br/>
            this.canvasDimensions.HEIGHT = opt_height;<br/>
        }<br/>
        this.currentFrame = GameOverPanel.animConfig.frames.length - 1;<br/>
    }<br/>
    drawGameOverText(dimensions, opt_useAltText) {<br/>
        const centerX = this.canvasDimensions.WIDTH / 2;<br/>
        let textSourceX = dimensions.TEXT_X;<br/>
        let textSourceY = dimensions.TEXT_Y;<br/>
        let textSourceWidth = dimensions.TEXT_WIDTH;<br/>
        let textSourceHeight = dimensions.TEXT_HEIGHT;<br/>
        const textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));<br/>
        const textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);<br/>
        const textTargetWidth = dimensions.TEXT_WIDTH;<br/>
        const textTargetHeight = dimensions.TEXT_HEIGHT;<br/>
        if (IS_HIDPI) {<br/>
            textSourceY *= 2;<br/>
            textSourceX *= 2;<br/>
            textSourceWidth *= 2;<br/>
            textSourceHeight *= 2;<br/>
        }<br/>
        if (!opt_useAltText) {<br/>
            textSourceX += this.textImgPos.x;<br/>
            textSourceY += this.textImgPos.y;<br/>
        }<br/>
        const spriteSource = opt_useAltText ? Runner.altCommonImageSprite : Runner.origImageSprite;<br/>
        this.canvasCtx.save();<br/>
        if (IS_RTL) {<br/>
            this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0);<br/>
            this.canvasCtx.scale(-1, 1);<br/>
        }<br/>
        // Game over text from sprite.<br/>
        this.canvasCtx.drawImage(spriteSource, textSourceX, textSourceY, textSourceWidth, textSourceHeight, textTargetX, textTargetY, textTargetWidth, textTargetHeight);<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    /**<br/>
     * Draw additional adornments for alternative game types.<br/>
     */<br/>
    drawAltGameElements(tRex) {<br/>
        // Additional adornments.<br/>
        if (this.altGameModeActive && Runner.spriteDefinition.ALT_GAME_END_CONFIG) {<br/>
            const altGameEndConfig = Runner.spriteDefinition.ALT_GAME_END_CONFIG;<br/>
            let altGameEndSourceWidth = altGameEndConfig.WIDTH;<br/>
            let altGameEndSourceHeight = altGameEndConfig.HEIGHT;<br/>
            const altGameEndTargetX = tRex.xPos + altGameEndConfig.X_OFFSET;<br/>
            const altGameEndTargetY = tRex.yPos + altGameEndConfig.Y_OFFSET;<br/>
            if (IS_HIDPI) {<br/>
                altGameEndSourceWidth *= 2;<br/>
                altGameEndSourceHeight *= 2;<br/>
            }<br/>
            this.canvasCtx.drawImage(Runner.altCommonImageSprite, this.altGameEndImgPos.x, this.altGameEndImgPos.y, altGameEndSourceWidth, altGameEndSourceHeight, altGameEndTargetX, altGameEndTargetY, altGameEndConfig.WIDTH, altGameEndConfig.HEIGHT);<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Draw restart button.<br/>
     */<br/>
    drawRestartButton() {<br/>
        const dimensions = GameOverPanel.dimensions;<br/>
        let framePosX = GameOverPanel.animConfig.frames[this.currentFrame];<br/>
        let restartSourceWidth = dimensions.RESTART_WIDTH;<br/>
        let restartSourceHeight = dimensions.RESTART_HEIGHT;<br/>
        const restartTargetX = (this.canvasDimensions.WIDTH / 2) - (dimensions.RESTART_WIDTH / 2);<br/>
        const restartTargetY = this.canvasDimensions.HEIGHT / 2;<br/>
        if (IS_HIDPI) {<br/>
            restartSourceWidth *= 2;<br/>
            restartSourceHeight *= 2;<br/>
            framePosX *= 2;<br/>
        }<br/>
        this.canvasCtx.save();<br/>
        if (IS_RTL) {<br/>
            this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0);<br/>
            this.canvasCtx.scale(-1, 1);<br/>
        }<br/>
        this.canvasCtx.drawImage(Runner.origImageSprite, this.restartImgPos.x + framePosX, this.restartImgPos.y, restartSourceWidth, restartSourceHeight, restartTargetX, restartTargetY, dimensions.RESTART_WIDTH, dimensions.RESTART_HEIGHT);<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    /**<br/>
     * Draw the panel.<br/>
     * @param {boolean} opt_altGameModeActive<br/>
     * @param {!Trex} opt_tRex<br/>
     */<br/>
    draw(opt_altGameModeActive, opt_tRex) {<br/>
        if (opt_altGameModeActive) {<br/>
            this.altGameModeActive = opt_altGameModeActive;<br/>
        }<br/>
        this.drawGameOverText(GameOverPanel.dimensions, false);<br/>
        this.drawRestartButton();<br/>
        this.drawAltGameElements(opt_tRex);<br/>
        this.update();<br/>
    }<br/>
    /**<br/>
     * Update animation frames.<br/>
     */<br/>
    update() {<br/>
        const now = getTimeStamp();<br/>
        const deltaTime = now - (this.frameTimeStamp || now);<br/>
        this.frameTimeStamp = now;<br/>
        this.animTimer += deltaTime;<br/>
        this.flashTimer += deltaTime;<br/>
        // Restart Button<br/>
        if (this.currentFrame === 0 &&<br/>
            this.animTimer &gt; GameOverPanel.LOGO_PAUSE_DURATION) {<br/>
            this.animTimer = 0;<br/>
            this.currentFrame++;<br/>
            this.drawRestartButton();<br/>
        }<br/>
        else if (this.currentFrame &gt; 0 &&<br/>
            this.currentFrame &lt; GameOverPanel.animConfig.frames.length) {<br/>
            if (this.animTimer &gt;= GameOverPanel.animConfig.msPerFrame) {<br/>
                this.currentFrame++;<br/>
                this.drawRestartButton();<br/>
            }<br/>
        }<br/>
        else if (!this.altGameModeActive &&<br/>
            this.currentFrame === GameOverPanel.animConfig.frames.length) {<br/>
            this.reset();<br/>
            return;<br/>
        }<br/>
        // Game over text<br/>
        if (this.altGameModeActive &&<br/>
            spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG) {<br/>
            const altTextConfig = spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG;<br/>
            if (altTextConfig.FLASHING) {<br/>
                if (this.flashCounter &lt; GameOverPanel.FLASH_ITERATIONS &&<br/>
                    this.flashTimer &gt; altTextConfig.FLASH_DURATION) {<br/>
                    this.flashTimer = 0;<br/>
                    this.originalText = !this.originalText;<br/>
                    this.clearGameOverTextBounds();<br/>
                    if (this.originalText) {<br/>
                        this.drawGameOverText(GameOverPanel.dimensions, false);<br/>
                        this.flashCounter++;<br/>
                    }<br/>
                    else {<br/>
                        this.drawGameOverText(altTextConfig, true);<br/>
                    }<br/>
                }<br/>
                else if (this.flashCounter &gt;= GameOverPanel.FLASH_ITERATIONS) {<br/>
                    this.reset();<br/>
                    return;<br/>
                }<br/>
            }<br/>
            else {<br/>
                this.clearGameOverTextBounds(altTextConfig);<br/>
                this.drawGameOverText(altTextConfig, true);<br/>
            }<br/>
        }<br/>
        this.gameOverRafId = requestAnimationFrame(this.update.bind(this));<br/>
    }<br/>
    /**<br/>
     * Clear game over text.<br/>
     * @param {Object} dimensions Game over text config.<br/>
     */<br/>
    clearGameOverTextBounds(dimensions) {<br/>
        this.canvasCtx.save();<br/>
        this.canvasCtx.clearRect(Math.round(this.canvasDimensions.WIDTH / 2 - (dimensions.TEXT_WIDTH / 2)), Math.round((this.canvasDimensions.HEIGHT - 25) / 3), dimensions.TEXT_WIDTH, dimensions.TEXT_HEIGHT + 4);<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    reset() {<br/>
        if (this.gameOverRafId) {<br/>
            cancelAnimationFrame(this.gameOverRafId);<br/>
            this.gameOverRafId = null;<br/>
        }<br/>
        this.animTimer = 0;<br/>
        this.frameTimeStamp = 0;<br/>
        this.currentFrame = 0;<br/>
        this.flashTimer = 0;<br/>
        this.flashCounter = 0;<br/>
        this.originalText = true;<br/>
    }<br/>
}<br/>
GameOverPanel.RESTART_ANIM_DURATION = 875;<br/>
GameOverPanel.LOGO_PAUSE_DURATION = 875;<br/>
GameOverPanel.FLASH_ITERATIONS = 5;<br/>
/**<br/>
 * Animation frames spec.<br/>
 */<br/>
GameOverPanel.animConfig = {<br/>
    frames: [0, 36, 72, 108, 144, 180, 216, 252],<br/>
    msPerFrame: GameOverPanel.RESTART_ANIM_DURATION / 8,<br/>
};<br/>
/**<br/>
 * Dimensions used in the panel.<br/>
 * @enum {number}<br/>
 */<br/>
GameOverPanel.dimensions = {<br/>
    TEXT_X: 0,<br/>
    TEXT_Y: 13,<br/>
    TEXT_WIDTH: 191,<br/>
    TEXT_HEIGHT: 11,<br/>
    RESTART_WIDTH: 36,<br/>
    RESTART_HEIGHT: 32,<br/>
};<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/**<br/>
 * Generated sound FX class for audio cues.<br/>
 */<br/>
class GeneratedSoundFx {<br/>
    audioCues = false;<br/>
    context = null;<br/>
    panner = null;<br/>
    bgSoundIntervalId = null;<br/>
    init() {<br/>
        this.audioCues = true;<br/>
        if (!this.context) {<br/>
            this.context = new AudioContext();<br/>
            if (IS_IOS) {<br/>
                this.context.onstatechange = () =&gt; {<br/>
                    assert(this.context);<br/>
                    if (this.context.state !== 'running') {<br/>
                        this.context.resume();<br/>
                    }<br/>
                };<br/>
                this.context.resume();<br/>
            }<br/>
            this.panner = this.context.createStereoPanner ?<br/>
                this.context.createStereoPanner() :<br/>
                null;<br/>
        }<br/>
    }<br/>
    stopAll() {<br/>
        this.cancelFootSteps();<br/>
    }<br/>
    /**<br/>
     * Play oscillators at certain frequency and for a certain time.<br/>
     */<br/>
    playNote(frequency, startTime, duration, vol = 0.01, pan = 0) {<br/>
        assert(this.context);<br/>
        const osc1 = this.context.createOscillator();<br/>
        const osc2 = this.context.createOscillator();<br/>
        const volume = this.context.createGain();<br/>
        // Set oscillator wave type<br/>
        osc1.type = 'triangle';<br/>
        osc2.type = 'triangle';<br/>
        volume.gain.value = 0.1;<br/>
        // Set up node routing<br/>
        if (this.panner) {<br/>
            this.panner.pan.value = pan;<br/>
            osc1.connect(volume).connect(this.panner);<br/>
            osc2.connect(volume).connect(this.panner);<br/>
            this.panner.connect(this.context.destination);<br/>
        }<br/>
        else {<br/>
            osc1.connect(volume);<br/>
            osc2.connect(volume);<br/>
            volume.connect(this.context.destination);<br/>
        }<br/>
        // Detune oscillators for chorus effect<br/>
        osc1.frequency.value = frequency + 1;<br/>
        osc2.frequency.value = frequency - 2;<br/>
        // Fade out<br/>
        volume.gain.setValueAtTime(vol, startTime + duration - 0.05);<br/>
        volume.gain.linearRampToValueAtTime(0.00001, startTime + duration);<br/>
        // Start oscillators<br/>
        osc1.start(startTime);<br/>
        osc2.start(startTime);<br/>
        // Stop oscillators<br/>
        osc1.stop(startTime + duration);<br/>
        osc2.stop(startTime + duration);<br/>
    }<br/>
    background() {<br/>
        assert(this.context);<br/>
        if (this.audioCues) {<br/>
            const now = this.context.currentTime;<br/>
            this.playNote(493.883, now, 0.116);<br/>
            this.playNote(659.255, now + 0.116, 0.232);<br/>
            this.loopFootSteps();<br/>
        }<br/>
    }<br/>
    loopFootSteps() {<br/>
        if (this.audioCues && !this.bgSoundIntervalId) {<br/>
            this.bgSoundIntervalId = setInterval(() =&gt; {<br/>
                assert(this.context);<br/>
                this.playNote(73.42, this.context.currentTime, 0.05, 0.16);<br/>
                this.playNote(69.30, this.context.currentTime + 0.116, 0.116, 0.16);<br/>
            }, 280);<br/>
        }<br/>
    }<br/>
    cancelFootSteps() {<br/>
        if (this.audioCues && this.bgSoundIntervalId) {<br/>
            assert(this.context);<br/>
            clearInterval(this.bgSoundIntervalId);<br/>
            this.bgSoundIntervalId = null;<br/>
            this.playNote(103.83, this.context.currentTime, 0.232, 0.02);<br/>
            this.playNote(116.54, this.context.currentTime + 0.116, 0.232, 0.02);<br/>
        }<br/>
    }<br/>
    collect() {<br/>
        if (this.audioCues) {<br/>
            assert(this.context);<br/>
            this.cancelFootSteps();<br/>
            const now = this.context.currentTime;<br/>
            this.playNote(830.61, now, 0.116);<br/>
            this.playNote(1318.51, now + 0.116, 0.232);<br/>
        }<br/>
    }<br/>
    jump() {<br/>
        if (this.audioCues) {<br/>
            assert(this.context);<br/>
            const now = this.context.currentTime;<br/>
            this.playNote(659.25, now, 0.116, 0.3, -0.6);<br/>
            this.playNote(880, now + 0.116, 0.232, 0.3, -0.6);<br/>
        }<br/>
    }<br/>
}<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class BackgroundEl {<br/>
    /**<br/>
     * Background item.<br/>
     * Similar to cloud, without random y position.<br/>
     * @param {HTMLCanvasElement} canvas Canvas element.<br/>
     * @param {Object} spritePos Position of image in sprite.<br/>
     * @param {number} containerWidth<br/>
     * @param {string} type Element type.<br/>
     */<br/>
    constructor(canvas, spritePos, containerWidth, type) {<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));<br/>
        this.spritePos = spritePos;<br/>
        this.containerWidth = containerWidth;<br/>
        this.xPos = containerWidth;<br/>
        this.yPos = 0;<br/>
        this.remove = false;<br/>
        this.type = type;<br/>
        this.gap =<br/>
            getRandomNum(BackgroundEl.config.MIN_GAP, BackgroundEl.config.MAX_GAP);<br/>
        this.animTimer = 0;<br/>
        this.switchFrames = false;<br/>
        this.spriteConfig = {};<br/>
        this.init();<br/>
    }<br/>
    /**<br/>
     * Initialise the element setting the y position.<br/>
     */<br/>
    init() {<br/>
        this.spriteConfig = Runner.spriteDefinition.BACKGROUND_EL[this.type];<br/>
        if (this.spriteConfig.FIXED) {<br/>
            this.xPos = this.spriteConfig.FIXED_X_POS;<br/>
        }<br/>
        this.yPos = BackgroundEl.config.Y_POS - this.spriteConfig.HEIGHT +<br/>
            this.spriteConfig.OFFSET;<br/>
        this.draw();<br/>
    }<br/>
    /**<br/>
     * Draw the element.<br/>
     */<br/>
    draw() {<br/>
        this.canvasCtx.save();<br/>
        let sourceWidth = this.spriteConfig.WIDTH;<br/>
        let sourceHeight = this.spriteConfig.HEIGHT;<br/>
        let sourceX = this.spriteConfig.X_POS;<br/>
        const outputWidth = sourceWidth;<br/>
        const outputHeight = sourceHeight;<br/>
        if (IS_HIDPI) {<br/>
            sourceWidth *= 2;<br/>
            sourceHeight *= 2;<br/>
            sourceX *= 2;<br/>
        }<br/>
        this.canvasCtx.drawImage(Runner.imageSprite, sourceX, this.spritePos.y, sourceWidth, sourceHeight, this.xPos, this.yPos, outputWidth, outputHeight);<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    /**<br/>
     * Update the background element position.<br/>
     * @param {number} speed<br/>
     */<br/>
    update(speed) {<br/>
        if (!this.remove) {<br/>
            if (this.spriteConfig.FIXED) {<br/>
                this.animTimer += speed;<br/>
                if (this.animTimer &gt; BackgroundEl.config.MS_PER_FRAME) {<br/>
                    this.animTimer = 0;<br/>
                    this.switchFrames = !this.switchFrames;<br/>
                }<br/>
                if (this.spriteConfig.FIXED_Y_POS_1 &&<br/>
                    this.spriteConfig.FIXED_Y_POS_2) {<br/>
                    this.yPos = this.switchFrames ? this.spriteConfig.FIXED_Y_POS_1 :<br/>
                        this.spriteConfig.FIXED_Y_POS_2;<br/>
                }<br/>
            }<br/>
            else {<br/>
                // Fixed speed, regardless of actual game speed.<br/>
                this.xPos -= BackgroundEl.config.SPEED;<br/>
            }<br/>
            this.draw();<br/>
            // Mark as removable if no longer in the canvas.<br/>
            if (!this.isVisible()) {<br/>
                this.remove = true;<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Check if the element is visible on the stage.<br/>
     * @return {boolean}<br/>
     */<br/>
    isVisible() {<br/>
        return this.xPos + this.spriteConfig.WIDTH &gt; 0;<br/>
    }<br/>
}<br/>
/**<br/>
 * Background element object config.<br/>
 * Real values assigned when game type changes.<br/>
 * @enum {number}<br/>
 */<br/>
BackgroundEl.config = {<br/>
    MAX_BG_ELS: 0,<br/>
    MAX_GAP: 0,<br/>
    MIN_GAP: 0,<br/>
    POS: 0,<br/>
    SPEED: 0,<br/>
    Y_POS: 0,<br/>
    MS_PER_FRAME: 0, // only needed when BACKGROUND_EL.FIXED is true<br/>
};<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class Cloud {<br/>
    /**<br/>
     * Cloud background item.<br/>
     * Similar to an obstacle object but without collision boxes.<br/>
     * @param {HTMLCanvasElement} canvas Canvas element.<br/>
     * @param {Object} spritePos Position of image in sprite.<br/>
     * @param {number} containerWidth<br/>
     */<br/>
    constructor(canvas, spritePos, containerWidth) {<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));<br/>
        this.spritePos = spritePos;<br/>
        this.containerWidth = containerWidth;<br/>
        this.xPos = containerWidth;<br/>
        this.yPos = 0;<br/>
        this.remove = false;<br/>
        this.gap =<br/>
            getRandomNum(Cloud.config.MIN_CLOUD_GAP, Cloud.config.MAX_CLOUD_GAP);<br/>
        this.init();<br/>
    }<br/>
    /**<br/>
     * Initialise the cloud. Sets the Cloud height.<br/>
     */<br/>
    init() {<br/>
        this.yPos =<br/>
            getRandomNum(Cloud.config.MAX_SKY_LEVEL, Cloud.config.MIN_SKY_LEVEL);<br/>
        this.draw();<br/>
    }<br/>
    /**<br/>
     * Draw the cloud.<br/>
     */<br/>
    draw() {<br/>
        this.canvasCtx.save();<br/>
        let sourceWidth = Cloud.config.WIDTH;<br/>
        let sourceHeight = Cloud.config.HEIGHT;<br/>
        const outputWidth = sourceWidth;<br/>
        const outputHeight = sourceHeight;<br/>
        if (IS_HIDPI) {<br/>
            sourceWidth = sourceWidth * 2;<br/>
            sourceHeight = sourceHeight * 2;<br/>
        }<br/>
        this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x, this.spritePos.y, sourceWidth, sourceHeight, this.xPos, this.yPos, outputWidth, outputHeight);<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    /**<br/>
     * Update the cloud position.<br/>
     * @param {number} speed<br/>
     */<br/>
    update(speed) {<br/>
        if (!this.remove) {<br/>
            this.xPos -= Math.ceil(speed);<br/>
            this.draw();<br/>
            // Mark as removable if no longer in the canvas.<br/>
            if (!this.isVisible()) {<br/>
                this.remove = true;<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Check if the cloud is visible on the stage.<br/>
     * @return {boolean}<br/>
     */<br/>
    isVisible() {<br/>
        return this.xPos + Cloud.config.WIDTH &gt; 0;<br/>
    }<br/>
}<br/>
/**<br/>
 * Cloud object config.<br/>
 * @enum {number}<br/>
 */<br/>
Cloud.config = {<br/>
    HEIGHT: 14,<br/>
    MAX_CLOUD_GAP: 400,<br/>
    MAX_SKY_LEVEL: 30,<br/>
    MIN_CLOUD_GAP: 100,<br/>
    MIN_SKY_LEVEL: 71,<br/>
    WIDTH: 46,<br/>
};<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class HorizonLine {<br/>
    /**<br/>
     * Horizon Line.<br/>
     * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.<br/>
     * @param {HTMLCanvasElement} canvas<br/>
     * @param {Object} lineConfig Configuration object.<br/>
     */<br/>
    constructor(canvas, lineConfig) {<br/>
        let sourceX = lineConfig.SOURCE_X;<br/>
        let sourceY = lineConfig.SOURCE_Y;<br/>
        if (IS_HIDPI) {<br/>
            sourceX *= 2;<br/>
            sourceY *= 2;<br/>
        }<br/>
        this.spritePos = { x: sourceX, y: sourceY };<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));<br/>
        this.sourceDimensions = {};<br/>
        this.dimensions = lineConfig;<br/>
        this.sourceXPos =<br/>
            [this.spritePos.x, this.spritePos.x + this.dimensions.WIDTH];<br/>
        this.xPos = [];<br/>
        this.yPos = 0;<br/>
        this.bumpThreshold = 0.5;<br/>
        this.setSourceDimensions(lineConfig);<br/>
        this.draw();<br/>
    }<br/>
    /**<br/>
     * Set the source dimensions of the horizon line.<br/>
     */<br/>
    setSourceDimensions(newDimensions) {<br/>
        for (const dimension in newDimensions) {<br/>
            if (dimension !== 'SOURCE_X' && dimension !== 'SOURCE_Y') {<br/>
                if (IS_HIDPI) {<br/>
                    if (dimension !== 'YPOS') {<br/>
                        this.sourceDimensions[dimension] = newDimensions[dimension] * 2;<br/>
                    }<br/>
                }<br/>
                else {<br/>
                    this.sourceDimensions[dimension] = newDimensions[dimension];<br/>
                }<br/>
                this.dimensions[dimension] = newDimensions[dimension];<br/>
            }<br/>
        }<br/>
        this.xPos = [0, newDimensions.WIDTH];<br/>
        this.yPos = newDimensions.YPOS;<br/>
    }<br/>
    /**<br/>
     * Return the crop x position of a type.<br/>
     */<br/>
    getRandomType() {<br/>
        return Math.random() &gt; this.bumpThreshold ? this.dimensions.WIDTH : 0;<br/>
    }<br/>
    /**<br/>
     * Draw the horizon line.<br/>
     */<br/>
    draw() {<br/>
        this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0], this.spritePos.y, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[0], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);<br/>
        this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1], this.spritePos.y, this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT, this.xPos[1], this.yPos, this.dimensions.WIDTH, this.dimensions.HEIGHT);<br/>
    }<br/>
    /**<br/>
     * Update the x position of an individual piece of the line.<br/>
     * @param {number} pos Line position.<br/>
     * @param {number} increment<br/>
     */<br/>
    updateXPos(pos, increment) {<br/>
        const line1 = pos;<br/>
        const line2 = pos === 0 ? 1 : 0;<br/>
        this.xPos[line1] -= increment;<br/>
        this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;<br/>
        if (this.xPos[line1] &lt;= -this.dimensions.WIDTH) {<br/>
            this.xPos[line1] += this.dimensions.WIDTH * 2;<br/>
            this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;<br/>
            this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Update the horizon line.<br/>
     * @param {number} deltaTime<br/>
     * @param {number} speed<br/>
     */<br/>
    update(deltaTime, speed) {<br/>
        const increment = Math.floor(speed * (FPS / 1000) * deltaTime);<br/>
        if (this.xPos[0] &lt;= 0) {<br/>
            this.updateXPos(0, increment);<br/>
        }<br/>
        else {<br/>
            this.updateXPos(1, increment);<br/>
        }<br/>
        this.draw();<br/>
    }<br/>
    /**<br/>
     * Reset horizon to the starting position.<br/>
     */<br/>
    reset() {<br/>
        this.xPos[0] = 0;<br/>
        this.xPos[1] = this.dimensions.WIDTH;<br/>
    }<br/>
}<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class NightMode {<br/>
    /**<br/>
     * Nightmode shows a moon and stars on the horizon.<br/>
     * @param {HTMLCanvasElement} canvas<br/>
     * @param {number} spritePos<br/>
     * @param {number} containerWidth<br/>
     */<br/>
    constructor(canvas, spritePos, containerWidth) {<br/>
        this.spritePos = spritePos;<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));<br/>
        this.xPos = containerWidth - 50;<br/>
        this.yPos = 30;<br/>
        this.currentPhase = 0;<br/>
        this.opacity = 0;<br/>
        this.containerWidth = containerWidth;<br/>
        this.stars = [];<br/>
        this.drawStars = false;<br/>
        this.placeStars();<br/>
    }<br/>
    /**<br/>
     * Update moving moon, changing phases.<br/>
     * @param {boolean} activated Whether night mode is activated.<br/>
     */<br/>
    update(activated) {<br/>
        // Moon phase.<br/>
        if (activated && this.opacity === 0) {<br/>
            this.currentPhase++;<br/>
            if (this.currentPhase &gt;= NightMode.phases.length) {<br/>
                this.currentPhase = 0;<br/>
            }<br/>
        }<br/>
        // Fade in / out.<br/>
        if (activated && (this.opacity &lt; 1 || this.opacity === 0)) {<br/>
            this.opacity += NightMode.config.FADE_SPEED;<br/>
        }<br/>
        else if (this.opacity &gt; 0) {<br/>
            this.opacity -= NightMode.config.FADE_SPEED;<br/>
        }<br/>
        // Set moon positioning.<br/>
        if (this.opacity &gt; 0) {<br/>
            this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);<br/>
            // Update stars.<br/>
            if (this.drawStars) {<br/>
                for (let i = 0; i &lt; NightMode.config.NUM_STARS; i++) {<br/>
                    this.stars[i].x =<br/>
                        this.updateXPos(this.stars[i].x, NightMode.config.STAR_SPEED);<br/>
                }<br/>
            }<br/>
            this.draw();<br/>
        }<br/>
        else {<br/>
            this.opacity = 0;<br/>
            this.placeStars();<br/>
        }<br/>
        this.drawStars = true;<br/>
    }<br/>
    updateXPos(currentPos, speed) {<br/>
        if (currentPos &lt; -NightMode.config.WIDTH) {<br/>
            currentPos = this.containerWidth;<br/>
        }<br/>
        else {<br/>
            currentPos -= speed;<br/>
        }<br/>
        return currentPos;<br/>
    }<br/>
    draw() {<br/>
        let moonSourceWidth = this.currentPhase === 3 ? NightMode.config.WIDTH * 2 :<br/>
            NightMode.config.WIDTH;<br/>
        let moonSourceHeight = NightMode.config.HEIGHT;<br/>
        let moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];<br/>
        const moonOutputWidth = moonSourceWidth;<br/>
        let starSize = NightMode.config.STAR_SIZE;<br/>
        let starSourceX = spriteDefinitionByType.original.LDPI.STAR.x;<br/>
        if (IS_HIDPI) {<br/>
            moonSourceWidth *= 2;<br/>
            moonSourceHeight *= 2;<br/>
            moonSourceX =<br/>
                this.spritePos.x + (NightMode.phases[this.currentPhase] * 2);<br/>
            starSize *= 2;<br/>
            starSourceX = spriteDefinitionByType.original.HDPI.STAR.x;<br/>
        }<br/>
        this.canvasCtx.save();<br/>
        this.canvasCtx.globalAlpha = this.opacity;<br/>
        // Stars.<br/>
        if (this.drawStars) {<br/>
            for (let i = 0; i &lt; NightMode.config.NUM_STARS; i++) {<br/>
                this.canvasCtx.drawImage(Runner.origImageSprite, starSourceX, this.stars[i].sourceY, starSize, starSize, Math.round(this.stars[i].x), this.stars[i].y, NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);<br/>
            }<br/>
        }<br/>
        // Moon.<br/>
        this.canvasCtx.drawImage(Runner.origImageSprite, moonSourceX, this.spritePos.y, moonSourceWidth, moonSourceHeight, Math.round(this.xPos), this.yPos, moonOutputWidth, NightMode.config.HEIGHT);<br/>
        this.canvasCtx.globalAlpha = 1;<br/>
        this.canvasCtx.restore();<br/>
    }<br/>
    // Do star placement.<br/>
    placeStars() {<br/>
        const segmentSize = Math.round(this.containerWidth / NightMode.config.NUM_STARS);<br/>
        for (let i = 0; i &lt; NightMode.config.NUM_STARS; i++) {<br/>
            this.stars[i] = {};<br/>
            this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));<br/>
            this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);<br/>
            if (IS_HIDPI) {<br/>
                this.stars[i].sourceY = spriteDefinitionByType.original.HDPI.STAR.y +<br/>
                    NightMode.config.STAR_SIZE * 2 * i;<br/>
            }<br/>
            else {<br/>
                this.stars[i].sourceY = spriteDefinitionByType.original.LDPI.STAR.y +<br/>
                    NightMode.config.STAR_SIZE * i;<br/>
            }<br/>
        }<br/>
    }<br/>
    reset() {<br/>
        this.currentPhase = 0;<br/>
        this.opacity = 0;<br/>
        this.update(false);<br/>
    }<br/>
}<br/>
/**<br/>
 * @enum {number}<br/>
 */<br/>
NightMode.config = {<br/>
    FADE_SPEED: 0.035,<br/>
    HEIGHT: 40,<br/>
    MOON_SPEED: 0.25,<br/>
    NUM_STARS: 2,<br/>
    STAR_SIZE: 9,<br/>
    STAR_SPEED: 0.3,<br/>
    STAR_MAX_Y: 70,<br/>
    WIDTH: 20,<br/>
};<br/>
NightMode.phases = [140, 120, 100, 60, 40, 20, 0];<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
class Obstacle {<br/>
    /**<br/>
     * Obstacle.<br/>
     * @param {CanvasRenderingContext2D} canvasCtx<br/>
     * @param {ObstacleType} type<br/>
     * @param {Object} spriteImgPos Obstacle position in sprite.<br/>
     * @param {Object} dimensions<br/>
     * @param {number} gapCoefficient Mutipler in determining the gap.<br/>
     * @param {number} speed<br/>
     * @param {number=} opt_xOffset<br/>
     * @param {boolean=} opt_isAltGameMode<br/>
     */<br/>
    constructor(canvasCtx, type, spriteImgPos, dimensions, gapCoefficient, speed, opt_xOffset, opt_isAltGameMode) {<br/>
        this.canvasCtx = canvasCtx;<br/>
        this.spritePos = spriteImgPos;<br/>
        this.typeConfig = type;<br/>
        this.gapCoefficient = Runner.slowDown ? gapCoefficient * 2 : gapCoefficient;<br/>
        this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);<br/>
        this.dimensions = dimensions;<br/>
        this.remove = false;<br/>
        this.xPos = dimensions.WIDTH + (opt_xOffset || 0);<br/>
        this.yPos = 0;<br/>
        this.width = 0;<br/>
        this.collisionBoxes = [];<br/>
        this.gap = 0;<br/>
        this.speedOffset = 0;<br/>
        this.altGameModeActive = opt_isAltGameMode;<br/>
        this.imageSprite = this.typeConfig.type === 'COLLECTABLE' ?<br/>
            Runner.altCommonImageSprite :<br/>
            this.altGameModeActive ? Runner.altGameImageSprite :<br/>
                Runner.imageSprite;<br/>
        // For animated obstacles.<br/>
        this.currentFrame = 0;<br/>
        this.timer = 0;<br/>
        this.init(speed);<br/>
    }<br/>
    /**<br/>
     * Initialise the DOM for the obstacle.<br/>
     * @param {number} speed<br/>
     */<br/>
    init(speed) {<br/>
        this.cloneCollisionBoxes();<br/>
        // Only allow sizing if we're at the right speed.<br/>
        if (this.size &gt; 1 && this.typeConfig.multipleSpeed &gt; speed) {<br/>
            this.size = 1;<br/>
        }<br/>
        this.width = this.typeConfig.width * this.size;<br/>
        // Check if obstacle can be positioned at various heights.<br/>
        if (Array.isArray(this.typeConfig.yPos)) {<br/>
            const yPosConfig = IS_MOBILE ? this.typeConfig.yPosMobile : this.typeConfig.yPos;<br/>
            this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];<br/>
        }<br/>
        else {<br/>
            this.yPos = this.typeConfig.yPos;<br/>
        }<br/>
        this.draw();<br/>
        // Make collision box adjustments,<br/>
        // Central box is adjusted to the size as one box.<br/>
        //      ____        ______        ________<br/>
        //    _|   |-|    _|     |-|    _|       |-|<br/>
        //   | |&lt;-&gt;| |   | |&lt;---&gt;| |   | |&lt;-----&gt;| |<br/>
        //   | | 1 | |   | |  2  | |   | |   3   | |<br/>
        //   |_|___|_|   |_|_____|_|   |_|_______|_|<br/>
        //<br/>
        if (this.size &gt; 1) {<br/>
            this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -<br/>
                this.collisionBoxes[2].width;<br/>
            this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;<br/>
        }<br/>
        // For obstacles that go at a different speed from the horizon.<br/>
        if (this.typeConfig.speedOffset) {<br/>
            this.speedOffset = Math.random() &gt; 0.5 ? this.typeConfig.speedOffset :<br/>
                -this.typeConfig.speedOffset;<br/>
        }<br/>
        this.gap = this.getGap(this.gapCoefficient, speed);<br/>
        // Increase gap for audio cues enabled.<br/>
        if (Runner.audioCues) {<br/>
            this.gap *= 2;<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Draw and crop based on size.<br/>
     */<br/>
    draw() {<br/>
        let sourceWidth = this.typeConfig.width;<br/>
        let sourceHeight = this.typeConfig.height;<br/>
        if (IS_HIDPI) {<br/>
            sourceWidth = sourceWidth * 2;<br/>
            sourceHeight = sourceHeight * 2;<br/>
        }<br/>
        // X position in sprite.<br/>
        let sourceX = (sourceWidth * this.size) * (0.5 * (this.size - 1)) + this.spritePos.x;<br/>
        // Animation frames.<br/>
        if (this.currentFrame &gt; 0) {<br/>
            sourceX += sourceWidth * this.currentFrame;<br/>
        }<br/>
        this.canvasCtx.drawImage(this.imageSprite, sourceX, this.spritePos.y, sourceWidth * this.size, sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size, this.typeConfig.height);<br/>
    }<br/>
    /**<br/>
     * Obstacle frame update.<br/>
     * @param {number} deltaTime<br/>
     * @param {number} speed<br/>
     */<br/>
    update(deltaTime, speed) {<br/>
        if (!this.remove) {<br/>
            if (this.typeConfig.speedOffset) {<br/>
                speed += this.speedOffset;<br/>
            }<br/>
            this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);<br/>
            // Update frame<br/>
            if (this.typeConfig.numFrames) {<br/>
                this.timer += deltaTime;<br/>
                if (this.timer &gt;= this.typeConfig.frameRate) {<br/>
                    this.currentFrame =<br/>
                        this.currentFrame === this.typeConfig.numFrames - 1 ?<br/>
                            0 :<br/>
                            this.currentFrame + 1;<br/>
                    this.timer = 0;<br/>
                }<br/>
            }<br/>
            this.draw();<br/>
            if (!this.isVisible()) {<br/>
                this.remove = true;<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Calculate a random gap size.<br/>
     * - Minimum gap gets wider as speed increases<br/>
     * @param {number} gapCoefficient<br/>
     * @param {number} speed<br/>
     * @return {number} The gap size.<br/>
     */<br/>
    getGap(gapCoefficient, speed) {<br/>
        const minGap = Math.round(this.width * speed + this.typeConfig.minGap * gapCoefficient);<br/>
        const maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);<br/>
        return getRandomNum(minGap, maxGap);<br/>
    }<br/>
    /**<br/>
     * Check if obstacle is visible.<br/>
     * @return {boolean} Whether the obstacle is in the game area.<br/>
     */<br/>
    isVisible() {<br/>
        return this.xPos + this.width &gt; 0;<br/>
    }<br/>
    /**<br/>
     * Make a copy of the collision boxes, since these will change based on<br/>
     * obstacle type and size.<br/>
     */<br/>
    cloneCollisionBoxes() {<br/>
        const collisionBoxes = this.typeConfig.collisionBoxes;<br/>
        for (let i = collisionBoxes.length - 1; i &gt;= 0; i--) {<br/>
            this.collisionBoxes[i] = new CollisionBox(collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width, collisionBoxes[i].height);<br/>
        }<br/>
    }<br/>
}<br/>
/**<br/>
 * Coefficient for calculating the maximum gap.<br/>
 */<br/>
Obstacle.MAX_GAP_COEFFICIENT = 1.5;<br/>
/**<br/>
 * Maximum obstacle grouping count.<br/>
 */<br/>
Obstacle.MAX_OBSTACLE_LENGTH = 3;<br/>
<br/>
// Copyright 2024 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/**<br/>
 * Horizon background class.<br/>
 */<br/>
class Horizon {<br/>
    /**<br/>
     * @param {HTMLCanvasElement} canvas<br/>
     * @param {Object} spritePos Sprite positioning.<br/>
     * @param {Object} dimensions Canvas dimensions.<br/>
     * @param {number} gapCoefficient<br/>
     */<br/>
    constructor(canvas, spritePos, dimensions, gapCoefficient) {<br/>
        this.canvas = canvas;<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));<br/>
        this.config = Horizon.config;<br/>
        this.dimensions = dimensions;<br/>
        this.gapCoefficient = gapCoefficient;<br/>
        this.obstacles = [];<br/>
        this.obstacleHistory = [];<br/>
        this.horizonOffsets = [0, 0];<br/>
        this.cloudFrequency = this.config.CLOUD_FREQUENCY;<br/>
        this.spritePos = spritePos;<br/>
        this.nightMode = null;<br/>
        this.altGameModeActive = false;<br/>
        // Cloud<br/>
        this.clouds = [];<br/>
        this.cloudSpeed = this.config.BG_CLOUD_SPEED;<br/>
        // Background elements<br/>
        this.backgroundEls = [];<br/>
        this.lastEl = null;<br/>
        this.backgroundSpeed = this.config.BG_CLOUD_SPEED;<br/>
        // Horizon<br/>
        this.horizonLine = null;<br/>
        this.horizonLines = [];<br/>
        this.init();<br/>
    }<br/>
    /**<br/>
     * Initialise the horizon. Just add the line and a cloud. No obstacles.<br/>
     */<br/>
    init() {<br/>
        Obstacle.types = spriteDefinitionByType.original.OBSTACLES;<br/>
        this.addCloud();<br/>
        // Multiple Horizon lines<br/>
        for (let i = 0; i &lt; Runner.spriteDefinition.LINES.length; i++) {<br/>
            this.horizonLines.push(new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]));<br/>
        }<br/>
        this.nightMode =<br/>
            new NightMode(this.canvas, this.spritePos.MOON, this.dimensions.WIDTH);<br/>
    }<br/>
    /**<br/>
     * Update obstacle definitions based on the speed of the game.<br/>
     */<br/>
    adjustObstacleSpeed() {<br/>
        for (let i = 0; i &lt; Obstacle.types.length; i++) {<br/>
            if (Runner.slowDown) {<br/>
                Obstacle.types[i].multipleSpeed = Obstacle.types[i].multipleSpeed / 2;<br/>
                Obstacle.types[i].minGap *= 1.5;<br/>
                Obstacle.types[i].minSpeed = Obstacle.types[i].minSpeed / 2;<br/>
                // Convert variable y position obstacles to fixed.<br/>
                if (typeof (Obstacle.types[i].yPos) === 'object') {<br/>
                    Obstacle.types[i].yPos = Obstacle.types[i].yPos[0];<br/>
                    Obstacle.types[i].yPosMobile = Obstacle.types[i].yPos[0];<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Update sprites to correspond to change in sprite sheet.<br/>
     * @param {number} spritePos<br/>
     */<br/>
    enableAltGameMode(spritePos) {<br/>
        // Clear existing horizon objects.<br/>
        this.clouds = [];<br/>
        this.backgroundEls = [];<br/>
        this.altGameModeActive = true;<br/>
        this.spritePos = spritePos;<br/>
        Obstacle.types = Runner.spriteDefinition.OBSTACLES;<br/>
        this.adjustObstacleSpeed();<br/>
        Obstacle.MAX_GAP_COEFFICIENT = Runner.spriteDefinition.MAX_GAP_COEFFICIENT;<br/>
        Obstacle.MAX_OBSTACLE_LENGTH = Runner.spriteDefinition.MAX_OBSTACLE_LENGTH;<br/>
        BackgroundEl.config = Runner.spriteDefinition.BACKGROUND_EL_CONFIG;<br/>
        this.horizonLines = [];<br/>
        for (let i = 0; i &lt; Runner.spriteDefinition.LINES.length; i++) {<br/>
            this.horizonLines.push(new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]));<br/>
        }<br/>
        this.reset();<br/>
    }<br/>
    /**<br/>
     * @param {number} deltaTime<br/>
     * @param {number} currentSpeed<br/>
     * @param {boolean} updateObstacles Used as an override to prevent<br/>
     *     the obstacles from being updated / added. This happens in the<br/>
     *     ease in section.<br/>
     * @param {boolean} showNightMode Night mode activated.<br/>
     */<br/>
    update(deltaTime, currentSpeed, updateObstacles, showNightMode) {<br/>
        this.runningTime += deltaTime;<br/>
        if (this.altGameModeActive) {<br/>
            this.updateBackgroundEls(deltaTime, currentSpeed);<br/>
        }<br/>
        for (let i = 0; i &lt; this.horizonLines.length; i++) {<br/>
            this.horizonLines[i].update(deltaTime, currentSpeed);<br/>
        }<br/>
        if (!this.altGameModeActive || Runner.spriteDefinition.HAS_CLOUDS) {<br/>
            this.nightMode.update(showNightMode);<br/>
            this.updateClouds(deltaTime, currentSpeed);<br/>
        }<br/>
        if (updateObstacles) {<br/>
            this.updateObstacles(deltaTime, currentSpeed);<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Update background element positions. Also handles creating new elements.<br/>
     * @param {number} elSpeed<br/>
     * @param {Array&lt;Object&gt;} bgElArray<br/>
     * @param {number} maxBgEl<br/>
     * @param {Function} bgElAddFunction<br/>
     * @param {number} frequency<br/>
     */<br/>
    updateBackgroundEl(elSpeed, bgElArray, maxBgEl, bgElAddFunction, frequency) {<br/>
        const numElements = bgElArray.length;<br/>
        if (numElements) {<br/>
            for (let i = numElements - 1; i &gt;= 0; i--) {<br/>
                bgElArray[i].update(elSpeed);<br/>
            }<br/>
            const lastEl = bgElArray[numElements - 1];<br/>
            // Check for adding a new element.<br/>
            if (numElements &lt; maxBgEl &&<br/>
                (this.dimensions.WIDTH - lastEl.xPos) &gt; lastEl.gap &&<br/>
                frequency &gt; Math.random()) {<br/>
                bgElAddFunction();<br/>
            }<br/>
        }<br/>
        else {<br/>
            bgElAddFunction();<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Update the cloud positions.<br/>
     * @param {number} deltaTime<br/>
     * @param {number} speed<br/>
     */<br/>
    updateClouds(deltaTime, speed) {<br/>
        const elSpeed = this.cloudSpeed / 1000 * deltaTime * speed;<br/>
        this.updateBackgroundEl(elSpeed, this.clouds, this.config.MAX_CLOUDS, this.addCloud.bind(this), this.cloudFrequency);<br/>
        // Remove expired elements.<br/>
        this.clouds = this.clouds.filter((obj) =&gt; !obj.remove);<br/>
    }<br/>
    /**<br/>
     * Update the background element positions.<br/>
     * @param {number} deltaTime<br/>
     * @param {number} speed<br/>
     */<br/>
    updateBackgroundEls(deltaTime, speed) {<br/>
        this.updateBackgroundEl(deltaTime, this.backgroundEls, BackgroundEl.config.MAX_BG_ELS, this.addBackgroundEl.bind(this), this.cloudFrequency);<br/>
        // Remove expired elements.<br/>
        this.backgroundEls = this.backgroundEls.filter((obj) =&gt; !obj.remove);<br/>
    }<br/>
    /**<br/>
     * Update the obstacle positions.<br/>
     * @param {number} deltaTime<br/>
     * @param {number} currentSpeed<br/>
     */<br/>
    updateObstacles(deltaTime, currentSpeed) {<br/>
        const updatedObstacles = this.obstacles.slice(0);<br/>
        for (let i = 0; i &lt; this.obstacles.length; i++) {<br/>
            const obstacle = this.obstacles[i];<br/>
            obstacle.update(deltaTime, currentSpeed);<br/>
            // Clean up existing obstacles.<br/>
            if (obstacle.remove) {<br/>
                updatedObstacles.shift();<br/>
            }<br/>
        }<br/>
        this.obstacles = updatedObstacles;<br/>
        if (this.obstacles.length &gt; 0) {<br/>
            const lastObstacle = this.obstacles[this.obstacles.length - 1];<br/>
            if (lastObstacle && !lastObstacle.followingObstacleCreated &&<br/>
                lastObstacle.isVisible() &&<br/>
                (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) &lt;<br/>
                    this.dimensions.WIDTH) {<br/>
                this.addNewObstacle(currentSpeed);<br/>
                lastObstacle.followingObstacleCreated = true;<br/>
            }<br/>
        }<br/>
        else {<br/>
            // Create new obstacles.<br/>
            this.addNewObstacle(currentSpeed);<br/>
        }<br/>
    }<br/>
    removeFirstObstacle() {<br/>
        this.obstacles.shift();<br/>
    }<br/>
    /**<br/>
     * Add a new obstacle.<br/>
     * @param {number} currentSpeed<br/>
     */<br/>
    addNewObstacle(currentSpeed) {<br/>
        const obstacleCount = Obstacle.types[Obstacle.types.length - 1].type !== 'COLLECTABLE' ||<br/>
            (Runner.isAltGameModeEnabled() && !this.altGameModeActive ||<br/>
                this.altGameModeActive) ?<br/>
            Obstacle.types.length - 1 :<br/>
            Obstacle.types.length - 2;<br/>
        const obstacleTypeIndex = obstacleCount &gt; 0 ? getRandomNum(0, obstacleCount) : 0;<br/>
        const obstacleType = Obstacle.types[obstacleTypeIndex];<br/>
        // Check for multiples of the same type of obstacle.<br/>
        // Also check obstacle is available at current speed.<br/>
        if ((obstacleCount &gt; 0 && this.duplicateObstacleCheck(obstacleType.type)) ||<br/>
            currentSpeed &lt; obstacleType.minSpeed) {<br/>
            this.addNewObstacle(currentSpeed);<br/>
        }<br/>
        else {<br/>
            const obstacleSpritePos = this.spritePos[obstacleType.type];<br/>
            this.obstacles.push(new Obstacle(this.canvasCtx, obstacleType, obstacleSpritePos, this.dimensions, this.gapCoefficient, currentSpeed, obstacleType.width, this.altGameModeActive));<br/>
            this.obstacleHistory.unshift(obstacleType.type);<br/>
            if (this.obstacleHistory.length &gt; 1) {<br/>
                this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);<br/>
            }<br/>
        }<br/>
    }<br/>
    /**<br/>
     * Returns whether the previous two obstacles are the same as the next one.<br/>
     * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.<br/>
     * @return {boolean}<br/>
     */<br/>
    duplicateObstacleCheck(nextObstacleType) {<br/>
        let duplicateCount = 0;<br/>
        for (let i = 0; i &lt; this.obstacleHistory.length; i++) {<br/>
            duplicateCount =<br/>
                this.obstacleHistory[i] === nextObstacleType ? duplicateCount + 1 : 0;<br/>
        }<br/>
        return duplicateCount &gt;= Runner.config.MAX_OBSTACLE_DUPLICATION;<br/>
    }<br/>
    /**<br/>
     * Reset the horizon layer.<br/>
     * Remove existing obstacles and reposition the horizon line.<br/>
     */<br/>
    reset() {<br/>
        this.obstacles = [];<br/>
        for (let l = 0; l &lt; this.horizonLines.length; l++) {<br/>
            this.horizonLines[l].reset();<br/>
        }<br/>
        this.nightMode.reset();<br/>
    }<br/>
    /**<br/>
     * Update the canvas width and scaling.<br/>
     * @param {number} width Canvas width.<br/>
     * @param {number} height Canvas height.<br/>
     */<br/>
    resize(width, height) {<br/>
        this.canvas.width = width;<br/>
        this.canvas.height = height;<br/>
    }<br/>
    /**<br/>
     * Add a new cloud to the horizon.<br/>
     */<br/>
    addCloud() {<br/>
        this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD, this.dimensions.WIDTH));<br/>
    }<br/>
    /**<br/>
     * Add a random background element to the horizon.<br/>
     */<br/>
    addBackgroundEl() {<br/>
        const backgroundElTypes = Object.keys(Runner.spriteDefinition.BACKGROUND_EL);<br/>
        if (backgroundElTypes.length &gt; 0) {<br/>
            let index = getRandomNum(0, backgroundElTypes.length - 1);<br/>
            let type = backgroundElTypes[index];<br/>
            // Add variation if available.<br/>
            while (type === this.lastEl && backgroundElTypes.length &gt; 1) {<br/>
                index = getRandomNum(0, backgroundElTypes.length - 1);<br/>
                type = backgroundElTypes[index];<br/>
            }<br/>
            this.lastEl = type;<br/>
            this.backgroundEls.push(new BackgroundEl(this.canvas, this.spritePos.BACKGROUND_EL, this.dimensions.WIDTH, type));<br/>
        }<br/>
    }<br/>
}<br/>
/**<br/>
 * Horizon config.<br/>
 * @enum {number}<br/>
 */<br/>
Horizon.config = {<br/>
    BG_CLOUD_SPEED: 0.2,<br/>
    BUMPY_THRESHOLD: .3,<br/>
    CLOUD_FREQUENCY: .5,<br/>
    HORIZON_HEIGHT: 16,<br/>
    MAX_CLOUDS: 6,<br/>
};<br/>
<br/>
// Copyright 2014 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
/**<br/>
 * T-Rex runner.<br/>
 * @param {string} outerContainerId Outer containing element id.<br/>
 * @param {!Object=} opt_config<br/>
 * @constructor<br/>
 * @implements {EventListener}<br/>
 * @export<br/>
 */<br/>
function Runner(outerContainerId, opt_config) {<br/>
    // Singleton<br/>
    if (Runner.instance_) {<br/>
        return Runner.instance_;<br/>
    }<br/>
    Runner.instance_ = this;<br/>
    this.outerContainerEl = document.querySelector(outerContainerId);<br/>
    this.containerEl = null;<br/>
    this.snackbarEl = null;<br/>
    // A div to intercept touch events. Only set while (playing && useTouch).<br/>
    this.touchController = null;<br/>
    this.config = opt_config || Object.assign(Runner.config, Runner.normalConfig);<br/>
    // Logical dimensions of the container.<br/>
    this.dimensions = Runner.defaultDimensions;<br/>
    this.gameType = null;<br/>
    Runner.spriteDefinition = spriteDefinitionByType['original'];<br/>
    this.altGameImageSprite = null;<br/>
    this.altGameModeActive = false;<br/>
    this.altGameModeFlashTimer = null;<br/>
    this.fadeInTimer = 0;<br/>
    this.canvas = null;<br/>
    this.canvasCtx = null;<br/>
    this.tRex = null;<br/>
    this.distanceMeter = null;<br/>
    this.distanceRan = 0;<br/>
    this.highestScore = 0;<br/>
    this.syncHighestScore = false;<br/>
    this.time = 0;<br/>
    this.runningTime = 0;<br/>
    this.msPerFrame = 1000 / FPS;<br/>
    this.currentSpeed = this.config.SPEED;<br/>
    Runner.slowDown = false;<br/>
    this.obstacles = [];<br/>
    this.activated = false; // Whether the easter egg has been activated.<br/>
    this.playing = false; // Whether the game is currently in play state.<br/>
    this.crashed = false;<br/>
    this.paused = false;<br/>
    this.inverted = false;<br/>
    this.invertTimer = 0;<br/>
    this.resizeTimerId_ = null;<br/>
    this.playCount = 0;<br/>
    // Sound FX.<br/>
    this.audioBuffer = null;<br/>
    /** @type {Object} */<br/>
    this.soundFx = {};<br/>
    this.generatedSoundFx = null;<br/>
    // Global web audio context for playing sounds.<br/>
    this.audioContext = null;<br/>
    // Images.<br/>
    this.images = {};<br/>
    this.imagesLoaded = 0;<br/>
    // Gamepad state.<br/>
    this.pollingGamepads = false;<br/>
    this.gamepadIndex = undefined;<br/>
    this.previousGamepad = null;<br/>
    if (this.isDisabled()) {<br/>
        this.setupDisabledRunner();<br/>
    }<br/>
    else {<br/>
        if (Runner.isAltGameModeEnabled()) {<br/>
            this.initAltGameType();<br/>
            Runner.gameType = this.gameType;<br/>
        }<br/>
        this.loadImages();<br/>
        window['initializeEasterEggHighScore'] =<br/>
            this.initializeHighScore.bind(this);<br/>
    }<br/>
}<br/>
/**<br/>
 * Default game width.<br/>
 * @const<br/>
 */<br/>
const DEFAULT_WIDTH = 600;<br/>
/** @const */<br/>
const ARCADE_MODE_URL = 'chrome://dino/';<br/>
/** @const */<br/>
const RESOURCE_POSTFIX = 'offline-resources-';<br/>
/** @const */<br/>
const A11Y_STRINGS = {<br/>
    ariaLabel: 'dinoGameA11yAriaLabel',<br/>
    description: 'dinoGameA11yDescription',<br/>
    gameOver: 'dinoGameA11yGameOver',<br/>
    highScore: 'dinoGameA11yHighScore',<br/>
    jump: 'dinoGameA11yJump',<br/>
    started: 'dinoGameA11yStartGame',<br/>
    speedLabel: 'dinoGameA11ySpeedToggle',<br/>
};<br/>
/**<br/>
 * Default game configuration.<br/>
 * Shared config for all  versions of the game. Additional parameters are<br/>
 * defined in Runner.normalConfig and Runner.slowConfig.<br/>
 */<br/>
Runner.config = {<br/>
    AUDIOCUE_PROXIMITY_THRESHOLD: 190,<br/>
    AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 250,<br/>
    BG_CLOUD_SPEED: 0.2,<br/>
    BOTTOM_PAD: 10,<br/>
    // Scroll Y threshold at which the game can be activated.<br/>
    CANVAS_IN_VIEW_OFFSET: -10,<br/>
    CLEAR_TIME: 3000,<br/>
    CLOUD_FREQUENCY: 0.5,<br/>
    FADE_DURATION: 1,<br/>
    FLASH_DURATION: 1000,<br/>
    GAMEOVER_CLEAR_TIME: 1200,<br/>
    INITIAL_JUMP_VELOCITY: 12,<br/>
    INVERT_FADE_DURATION: 12000,<br/>
    MAX_BLINK_COUNT: 3,<br/>
    MAX_CLOUDS: 6,<br/>
    MAX_OBSTACLE_LENGTH: 3,<br/>
    MAX_OBSTACLE_DUPLICATION: 2,<br/>
    RESOURCE_TEMPLATE_ID: 'audio-resources',<br/>
    SPEED: 6,<br/>
    SPEED_DROP_COEFFICIENT: 3,<br/>
    ARCADE_MODE_INITIAL_TOP_POSITION: 35,<br/>
    ARCADE_MODE_TOP_POSITION_PERCENT: 0.1,<br/>
};<br/>
Runner.normalConfig = {<br/>
    ACCELERATION: 0.001,<br/>
    AUDIOCUE_PROXIMITY_THRESHOLD: 190,<br/>
    AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 250,<br/>
    GAP_COEFFICIENT: 0.6,<br/>
    INVERT_DISTANCE: 700,<br/>
    MAX_SPEED: 13,<br/>
    MOBILE_SPEED_COEFFICIENT: 1.2,<br/>
    SPEED: 6,<br/>
};<br/>
Runner.slowConfig = {<br/>
    ACCELERATION: 0.0005,<br/>
    AUDIOCUE_PROXIMITY_THRESHOLD: 170,<br/>
    AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y: 220,<br/>
    GAP_COEFFICIENT: 0.3,<br/>
    INVERT_DISTANCE: 350,<br/>
    MAX_SPEED: 9,<br/>
    MOBILE_SPEED_COEFFICIENT: 1.5,<br/>
    SPEED: 4.2,<br/>
};<br/>
/**<br/>
 * Default dimensions.<br/>
 */<br/>
Runner.defaultDimensions = {<br/>
    WIDTH: DEFAULT_WIDTH,<br/>
    HEIGHT: 150,<br/>
};<br/>
/**<br/>
 * CSS class names.<br/>
 * @enum {string}<br/>
 */<br/>
Runner.classes = {<br/>
    ARCADE_MODE: 'arcade-mode',<br/>
    CANVAS: 'runner-canvas',<br/>
    CONTAINER: 'runner-container',<br/>
    CRASHED: 'crashed',<br/>
    ICON: 'icon-offline',<br/>
    INVERTED: 'inverted',<br/>
    SNACKBAR: 'snackbar',<br/>
    SNACKBAR_SHOW: 'snackbar-show',<br/>
    TOUCH_CONTROLLER: 'controller',<br/>
};<br/>
/**<br/>
 * Sound FX. Reference to the ID of the audio tag on interstitial page.<br/>
 * @enum {string}<br/>
 */<br/>
Runner.sounds = {<br/>
    BUTTON_PRESS: 'offline-sound-press',<br/>
    HIT: 'offline-sound-hit',<br/>
    SCORE: 'offline-sound-reached',<br/>
};<br/>
/**<br/>
 * Key code mapping.<br/>
 * @enum {Object}<br/>
 */<br/>
Runner.keycodes = {<br/>
    JUMP: { '38': 1, '32': 1 }, // Up, spacebar<br/>
    DUCK: { '40': 1 }, // Down<br/>
    RESTART: { '13': 1 }, // Enter<br/>
};<br/>
/**<br/>
 * Runner event names.<br/>
 * @enum {string}<br/>
 */<br/>
Runner.events = {<br/>
    ANIM_END: 'webkitAnimationEnd',<br/>
    CLICK: 'click',<br/>
    KEYDOWN: 'keydown',<br/>
    KEYUP: 'keyup',<br/>
    POINTERDOWN: 'pointerdown',<br/>
    POINTERUP: 'pointerup',<br/>
    RESIZE: 'resize',<br/>
    TOUCHEND: 'touchend',<br/>
    TOUCHSTART: 'touchstart',<br/>
    VISIBILITY: 'visibilitychange',<br/>
    BLUR: 'blur',<br/>
    FOCUS: 'focus',<br/>
    LOAD: 'load',<br/>
    GAMEPADCONNECTED: 'gamepadconnected',<br/>
};<br/>
Runner.prototype = {<br/>
    /**<br/>
     * Initialize alternative game type.<br/>
     */<br/>
    initAltGameType() {<br/>
        if (GAME_TYPE.length &gt; 0) {<br/>
            this.gameType = loadTimeData && loadTimeData.valueExists('altGameType') ?<br/>
                GAME_TYPE[parseInt(loadTimeData.getValue('altGameType'), 10) - 1] :<br/>
                '';<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Whether the easter egg has been disabled. CrOS enterprise enrolled devices.<br/>
     * @return {boolean}<br/>
     */<br/>
    isDisabled() {<br/>
        return loadTimeData && loadTimeData.valueExists('disabledEasterEgg');<br/>
    },<br/>
    /**<br/>
     * For disabled instances, set up a snackbar with the disabled message.<br/>
     */<br/>
    setupDisabledRunner() {<br/>
        this.containerEl = document.createElement('div');<br/>
        this.containerEl.className = Runner.classes.SNACKBAR;<br/>
        this.containerEl.textContent = loadTimeData.getValue('disabledEasterEgg');<br/>
        this.outerContainerEl.appendChild(this.containerEl);<br/>
        // Show notification when the activation key is pressed.<br/>
        document.addEventListener(Runner.events.KEYDOWN, function (e) {<br/>
            if (Runner.keycodes.JUMP[e.keyCode]) {<br/>
                this.containerEl.classList.add(Runner.classes.SNACKBAR_SHOW);<br/>
                document.querySelector('.icon').classList.add('icon-disabled');<br/>
            }<br/>
        }.bind(this));<br/>
    },<br/>
    /**<br/>
     * Setting individual settings for debugging.<br/>
     * @param {string} setting<br/>
     * @param {number|string} value<br/>
     */<br/>
    updateConfigSetting(setting, value) {<br/>
        if (setting in this.config && value !== undefined) {<br/>
            this.config[setting] = value;<br/>
            switch (setting) {<br/>
                case 'GRAVITY':<br/>
                case 'MIN_JUMP_HEIGHT':<br/>
                case 'SPEED_DROP_COEFFICIENT':<br/>
                    this.tRex.config[setting] = value;<br/>
                    break;<br/>
                case 'INITIAL_JUMP_VELOCITY':<br/>
                    this.tRex.setJumpVelocity(value);<br/>
                    break;<br/>
                case 'SPEED':<br/>
                    this.setSpeed(/** @type {number} */ (value));<br/>
                    break;<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Creates an on page image element from the base 64 encoded string source.<br/>
     * @param {string} resourceName Name in data object,<br/>
     * @return {HTMLImageElement} The created element.<br/>
     */<br/>
    createImageElement(resourceName) {<br/>
        const imgSrc = loadTimeData && loadTimeData.valueExists(resourceName) ?<br/>
            loadTimeData.getString(resourceName) :<br/>
            null;<br/>
        if (imgSrc) {<br/>
            const el = <br/>
            /** @type {HTMLImageElement} */ (document.createElement('img'));<br/>
            el.id = resourceName;<br/>
            el.src = imgSrc;<br/>
            document.getElementById('offline-resources').appendChild(el);<br/>
            return el;<br/>
        }<br/>
        return null;<br/>
    },<br/>
    /**<br/>
     * Cache the appropriate image sprite from the page and get the sprite sheet<br/>
     * definition.<br/>
     */<br/>
    loadImages() {<br/>
        let scale = '1x';<br/>
        this.spriteDef = Runner.spriteDefinition.LDPI;<br/>
        if (IS_HIDPI) {<br/>
            scale = '2x';<br/>
            this.spriteDef = Runner.spriteDefinition.HDPI;<br/>
        }<br/>
        Runner.imageSprite = /** @type {HTMLImageElement} */<br/>
            (document.getElementById(RESOURCE_POSTFIX + scale));<br/>
        if (this.gameType) {<br/>
            Runner.altGameImageSprite = /** @type {HTMLImageElement} */<br/>
                (this.createImageElement('altGameSpecificImage' + scale));<br/>
            Runner.altCommonImageSprite = /** @type {HTMLImageElement} */<br/>
                (this.createImageElement('altGameCommonImage' + scale));<br/>
        }<br/>
        Runner.origImageSprite = Runner.imageSprite;<br/>
        // Disable the alt game mode if the sprites can't be loaded.<br/>
        if (!Runner.altGameImageSprite || !Runner.altCommonImageSprite) {<br/>
            Runner.isAltGameModeEnabled = () =&gt; false;<br/>
            this.altGameModeActive = false;<br/>
        }<br/>
        if (Runner.imageSprite.complete) {<br/>
            this.init();<br/>
        }<br/>
        else {<br/>
            // If the images are not yet loaded, add a listener.<br/>
            Runner.imageSprite.addEventListener(Runner.events.LOAD, this.init.bind(this));<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Load and decode base 64 encoded sounds.<br/>
     */<br/>
    loadSounds() {<br/>
        if (!IS_IOS) {<br/>
            this.audioContext = new AudioContext();<br/>
            const resourceTemplate = document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;<br/>
            for (const sound in Runner.sounds) {<br/>
                let soundSrc = resourceTemplate.getElementById(Runner.sounds[sound]).src;<br/>
                soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);<br/>
                const buffer = decodeBase64ToArrayBuffer(soundSrc);<br/>
                // Async, so no guarantee of order in array.<br/>
                this.audioContext.decodeAudioData(buffer, function (index, audioData) {<br/>
                    this.soundFx[index] = audioData;<br/>
                }.bind(this, sound));<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Sets the game speed. Adjust the speed accordingly if on a smaller screen.<br/>
     * @param {number=} opt_speed<br/>
     */<br/>
    setSpeed(opt_speed) {<br/>
        const speed = opt_speed || this.currentSpeed;<br/>
        // Reduce the speed on smaller mobile screens.<br/>
        if (this.dimensions.WIDTH &lt; DEFAULT_WIDTH) {<br/>
            const mobileSpeed = Runner.slowDown ? speed :<br/>
                speed * this.dimensions.WIDTH /<br/>
                    DEFAULT_WIDTH * this.config.MOBILE_SPEED_COEFFICIENT;<br/>
            this.currentSpeed = mobileSpeed &gt; speed ? speed : mobileSpeed;<br/>
        }<br/>
        else if (opt_speed) {<br/>
            this.currentSpeed = opt_speed;<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Game initialiser.<br/>
     */<br/>
    init() {<br/>
        // Hide the static icon.<br/>
        document.querySelector('.' + Runner.classes.ICON).style.visibility =<br/>
            'hidden';<br/>
        if (this.isArcadeMode()) {<br/>
            document.title =<br/>
                document.title + ' - ' + getA11yString(A11Y_STRINGS.ariaLabel);<br/>
        }<br/>
        this.adjustDimensions();<br/>
        this.setSpeed();<br/>
        const ariaLabel = getA11yString(A11Y_STRINGS.ariaLabel);<br/>
        this.containerEl = document.createElement('div');<br/>
        this.containerEl.setAttribute('role', IS_MOBILE ? 'button' : 'application');<br/>
        this.containerEl.setAttribute('tabindex', '0');<br/>
        this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.description));<br/>
        this.containerEl.setAttribute('aria-label', ariaLabel);<br/>
        this.containerEl.className = Runner.classes.CONTAINER;<br/>
        // Player canvas container.<br/>
        this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH, this.dimensions.HEIGHT);<br/>
        // Live region for game status updates.<br/>
        this.a11yStatusEl = document.createElement('span');<br/>
        this.a11yStatusEl.className = 'offline-runner-live-region';<br/>
        this.a11yStatusEl.setAttribute('aria-live', 'assertive');<br/>
        this.a11yStatusEl.textContent = '';<br/>
        Runner.a11yStatusEl = this.a11yStatusEl;<br/>
        // Add checkbox to slow down the game.<br/>
        this.slowSpeedCheckboxLabel = document.createElement('label');<br/>
        this.slowSpeedCheckboxLabel.className = 'slow-speed-option hidden';<br/>
        this.slowSpeedCheckboxLabel.textContent =<br/>
            getA11yString(A11Y_STRINGS.speedLabel);<br/>
        this.slowSpeedCheckbox = document.createElement('input');<br/>
        this.slowSpeedCheckbox.setAttribute('type', 'checkbox');<br/>
        this.slowSpeedCheckbox.setAttribute('title', getA11yString(A11Y_STRINGS.speedLabel));<br/>
        this.slowSpeedCheckbox.setAttribute('tabindex', '0');<br/>
        this.slowSpeedCheckbox.setAttribute('checked', 'checked');<br/>
        this.slowSpeedToggleEl = document.createElement('span');<br/>
        this.slowSpeedToggleEl.className = 'slow-speed-toggle';<br/>
        this.slowSpeedCheckboxLabel.appendChild(this.slowSpeedCheckbox);<br/>
        this.slowSpeedCheckboxLabel.appendChild(this.slowSpeedToggleEl);<br/>
        if (IS_IOS) {<br/>
            this.outerContainerEl.appendChild(this.a11yStatusEl);<br/>
        }<br/>
        else {<br/>
            this.containerEl.appendChild(this.a11yStatusEl);<br/>
        }<br/>
        this.generatedSoundFx = new GeneratedSoundFx();<br/>
        this.canvasCtx =<br/>
            /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));<br/>
        this.canvasCtx.fillStyle = '#f7f7f7';<br/>
        this.canvasCtx.fill();<br/>
        Runner.updateCanvasScaling(this.canvas);<br/>
        // Horizon contains clouds, obstacles and the ground.<br/>
        this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions, this.config.GAP_COEFFICIENT);<br/>
        // Distance meter<br/>
        this.distanceMeter = new DistanceMeter(this.canvas, this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);<br/>
        // Draw t-rex<br/>
        this.tRex = new Trex(this.canvas, this.spriteDef.TREX);<br/>
        this.outerContainerEl.appendChild(this.containerEl);<br/>
        this.outerContainerEl.appendChild(this.slowSpeedCheckboxLabel);<br/>
        this.startListening();<br/>
        this.update();<br/>
        window.addEventListener(Runner.events.RESIZE, this.debounceResize.bind(this));<br/>
        // Handle dark mode<br/>
        const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');<br/>
        this.isDarkMode = darkModeMediaQuery && darkModeMediaQuery.matches;<br/>
        darkModeMediaQuery.addListener((e) =&gt; {<br/>
            this.isDarkMode = e.matches;<br/>
        });<br/>
    },<br/>
    /**<br/>
     * Create the touch controller. A div that covers whole screen.<br/>
     */<br/>
    createTouchController() {<br/>
        this.touchController = document.createElement('div');<br/>
        this.touchController.className = Runner.classes.TOUCH_CONTROLLER;<br/>
        this.touchController.addEventListener(Runner.events.TOUCHSTART, this);<br/>
        this.touchController.addEventListener(Runner.events.TOUCHEND, this);<br/>
        this.outerContainerEl.appendChild(this.touchController);<br/>
    },<br/>
    /**<br/>
     * Debounce the resize event.<br/>
     */<br/>
    debounceResize() {<br/>
        if (!this.resizeTimerId_) {<br/>
            this.resizeTimerId_ = setInterval(this.adjustDimensions.bind(this), 250);<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Adjust game space dimensions on resize.<br/>
     */<br/>
    adjustDimensions() {<br/>
        clearInterval(this.resizeTimerId_);<br/>
        this.resizeTimerId_ = null;<br/>
        const boxStyles = window.getComputedStyle(this.outerContainerEl);<br/>
        const padding = Number(boxStyles.paddingLeft.substr(0, boxStyles.paddingLeft.length - 2));<br/>
        this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;<br/>
        if (this.isArcadeMode()) {<br/>
            this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);<br/>
            if (this.activated) {<br/>
                this.setArcadeModeContainerScale();<br/>
            }<br/>
        }<br/>
        // Redraw the elements back onto the canvas.<br/>
        if (this.canvas) {<br/>
            this.canvas.width = this.dimensions.WIDTH;<br/>
            this.canvas.height = this.dimensions.HEIGHT;<br/>
            Runner.updateCanvasScaling(this.canvas);<br/>
            this.distanceMeter.calcXPos(this.dimensions.WIDTH);<br/>
            this.clearCanvas();<br/>
            this.horizon.update(0, 0, true);<br/>
            this.tRex.update(0);<br/>
            // Outer container and distance meter.<br/>
            if (this.playing || this.crashed || this.paused) {<br/>
                this.containerEl.style.width = this.dimensions.WIDTH + 'px';<br/>
                this.containerEl.style.height = this.dimensions.HEIGHT + 'px';<br/>
                this.distanceMeter.update(0, Math.ceil(this.distanceRan));<br/>
                this.stop();<br/>
            }<br/>
            else {<br/>
                this.tRex.draw(0, 0);<br/>
            }<br/>
            // Game over panel.<br/>
            if (this.crashed && this.gameOverPanel) {<br/>
                this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);<br/>
                this.gameOverPanel.draw(this.altGameModeActive, this.tRex);<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Play the game intro.<br/>
     * Canvas container width expands out to the full width.<br/>
     */<br/>
    playIntro() {<br/>
        if (!this.activated && !this.crashed) {<br/>
            this.playingIntro = true;<br/>
            this.tRex.playingIntro = true;<br/>
            // CSS animation definition.<br/>
            const keyframes = '@-webkit-keyframes intro { ' +<br/>
                'from { width:' + Trex.config.WIDTH + 'px }' +<br/>
                'to { width: ' + this.dimensions.WIDTH + 'px }' +<br/>
                '}';<br/>
            document.styleSheets[0].insertRule(keyframes, 0);<br/>
            this.containerEl.addEventListener(Runner.events.ANIM_END, this.startGame.bind(this));<br/>
            this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';<br/>
            this.containerEl.style.width = this.dimensions.WIDTH + 'px';<br/>
            this.setPlayStatus(true);<br/>
            this.activated = true;<br/>
        }<br/>
        else if (this.crashed) {<br/>
            this.restart();<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Update the game status to started.<br/>
     */<br/>
    startGame() {<br/>
        if (this.isArcadeMode()) {<br/>
            this.setArcadeMode();<br/>
        }<br/>
        this.toggleSpeed();<br/>
        this.runningTime = 0;<br/>
        this.playingIntro = false;<br/>
        this.tRex.playingIntro = false;<br/>
        this.containerEl.style.webkitAnimation = '';<br/>
        this.playCount++;<br/>
        this.generatedSoundFx.background();<br/>
        if (Runner.audioCues) {<br/>
            this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump));<br/>
        }<br/>
        // Handle tabbing off the page. Pause the current game.<br/>
        document.addEventListener(Runner.events.VISIBILITY, this.onVisibilityChange.bind(this));<br/>
        window.addEventListener(Runner.events.BLUR, this.onVisibilityChange.bind(this));<br/>
        window.addEventListener(Runner.events.FOCUS, this.onVisibilityChange.bind(this));<br/>
    },<br/>
    clearCanvas() {<br/>
        this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH, this.dimensions.HEIGHT);<br/>
    },<br/>
    /**<br/>
     * Checks whether the canvas area is in the viewport of the browser<br/>
     * through the current scroll position.<br/>
     * @return boolean.<br/>
     */<br/>
    isCanvasInView() {<br/>
        return this.containerEl.getBoundingClientRect().top &gt;<br/>
            Runner.config.CANVAS_IN_VIEW_OFFSET;<br/>
    },<br/>
    /**<br/>
     * Enable the alt game mode. Switching out the sprites.<br/>
     */<br/>
    enableAltGameMode() {<br/>
        Runner.imageSprite = Runner.altGameImageSprite;<br/>
        Runner.spriteDefinition = spriteDefinitionByType[Runner.gameType];<br/>
        if (IS_HIDPI) {<br/>
            this.spriteDef = Runner.spriteDefinition.HDPI;<br/>
        }<br/>
        else {<br/>
            this.spriteDef = Runner.spriteDefinition.LDPI;<br/>
        }<br/>
        this.altGameModeActive = true;<br/>
        this.tRex.enableAltGameMode(this.spriteDef.TREX);<br/>
        this.horizon.enableAltGameMode(this.spriteDef);<br/>
        this.generatedSoundFx.background();<br/>
    },<br/>
    /**<br/>
     * Update the game frame and schedules the next one.<br/>
     */<br/>
    update() {<br/>
        this.updatePending = false;<br/>
        const now = getTimeStamp();<br/>
        let deltaTime = now - (this.time || now);<br/>
        // Flashing when switching game modes.<br/>
        if (this.altGameModeFlashTimer &lt; 0 || this.altGameModeFlashTimer === 0) {<br/>
            this.altGameModeFlashTimer = null;<br/>
            this.tRex.setFlashing(false);<br/>
            this.enableAltGameMode();<br/>
        }<br/>
        else if (this.altGameModeFlashTimer &gt; 0) {<br/>
            this.altGameModeFlashTimer -= deltaTime;<br/>
            this.tRex.update(deltaTime);<br/>
            deltaTime = 0;<br/>
        }<br/>
        this.time = now;<br/>
        if (this.playing) {<br/>
            this.clearCanvas();<br/>
            // Additional fade in - Prevents jump when switching sprites<br/>
            if (this.altGameModeActive &&<br/>
                this.fadeInTimer &lt;= this.config.FADE_DURATION) {<br/>
                this.fadeInTimer += deltaTime / 1000;<br/>
                this.canvasCtx.globalAlpha = this.fadeInTimer;<br/>
            }<br/>
            else {<br/>
                this.canvasCtx.globalAlpha = 1;<br/>
            }<br/>
            if (this.tRex.jumping) {<br/>
                this.tRex.updateJump(deltaTime);<br/>
            }<br/>
            this.runningTime += deltaTime;<br/>
            const hasObstacles = this.runningTime &gt; this.config.CLEAR_TIME;<br/>
            // First jump triggers the intro.<br/>
            if (this.tRex.jumpCount === 1 && !this.playingIntro) {<br/>
                this.playIntro();<br/>
            }<br/>
            // The horizon doesn't move until the intro is over.<br/>
            if (this.playingIntro) {<br/>
                this.horizon.update(0, this.currentSpeed, hasObstacles);<br/>
            }<br/>
            else if (!this.crashed) {<br/>
                const showNightMode = this.isDarkMode ^ this.inverted;<br/>
                deltaTime = !this.activated ? 0 : deltaTime;<br/>
                this.horizon.update(deltaTime, this.currentSpeed, hasObstacles, showNightMode);<br/>
            }<br/>
            // Check for collisions.<br/>
            let collision = hasObstacles &&<br/>
                checkForCollision(this.horizon.obstacles[0], this.tRex);<br/>
            // For a11y, audio cues.<br/>
            if (Runner.audioCues && hasObstacles) {<br/>
                const jumpObstacle = this.horizon.obstacles[0].typeConfig.type !== 'COLLECTABLE';<br/>
                if (!this.horizon.obstacles[0].jumpAlerted) {<br/>
                    const threshold = Runner.isMobileMouseInput ?<br/>
                        Runner.config.AUDIOCUE_PROXIMITY_THRESHOLD_MOBILE_A11Y :<br/>
                        Runner.config.AUDIOCUE_PROXIMITY_THRESHOLD;<br/>
                    const adjProximityThreshold = threshold +<br/>
                        (threshold * Math.log10(this.currentSpeed / Runner.config.SPEED));<br/>
                    if (this.horizon.obstacles[0].xPos &lt; adjProximityThreshold) {<br/>
                        if (jumpObstacle) {<br/>
                            this.generatedSoundFx.jump();<br/>
                        }<br/>
                        this.horizon.obstacles[0].jumpAlerted = true;<br/>
                    }<br/>
                }<br/>
            }<br/>
            // Activated alt game mode.<br/>
            if (Runner.isAltGameModeEnabled() && collision &&<br/>
                this.horizon.obstacles[0].typeConfig.type === 'COLLECTABLE') {<br/>
                this.horizon.removeFirstObstacle();<br/>
                this.tRex.setFlashing(true);<br/>
                collision = false;<br/>
                this.altGameModeFlashTimer = this.config.FLASH_DURATION;<br/>
                this.runningTime = 0;<br/>
                this.generatedSoundFx.collect();<br/>
            }<br/>
            if (!collision) {<br/>
                this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;<br/>
                if (this.currentSpeed &lt; this.config.MAX_SPEED) {<br/>
                    this.currentSpeed += this.config.ACCELERATION;<br/>
                }<br/>
            }<br/>
            else {<br/>
                this.gameOver();<br/>
            }<br/>
            const playAchievementSound = this.distanceMeter.update(deltaTime, Math.ceil(this.distanceRan));<br/>
            if (!Runner.audioCues && playAchievementSound) {<br/>
                this.playSound(this.soundFx.SCORE);<br/>
            }<br/>
            // Night mode.<br/>
            if (!Runner.isAltGameModeEnabled()) {<br/>
                if (this.invertTimer &gt; this.config.INVERT_FADE_DURATION) {<br/>
                    this.invertTimer = 0;<br/>
                    this.invertTrigger = false;<br/>
                    this.invert(false);<br/>
                }<br/>
                else if (this.invertTimer) {<br/>
                    this.invertTimer += deltaTime;<br/>
                }<br/>
                else {<br/>
                    const actualDistance = this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));<br/>
                    if (actualDistance &gt; 0) {<br/>
                        this.invertTrigger =<br/>
                            !(actualDistance % this.config.INVERT_DISTANCE);<br/>
                        if (this.invertTrigger && this.invertTimer === 0) {<br/>
                            this.invertTimer += deltaTime;<br/>
                            this.invert(false);<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
        if (this.playing ||<br/>
            (!this.activated &&<br/>
                this.tRex.blinkCount &lt; Runner.config.MAX_BLINK_COUNT)) {<br/>
            this.tRex.update(deltaTime);<br/>
            this.scheduleNextUpdate();<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Event handler.<br/>
     * @param {Event} e<br/>
     */<br/>
    handleEvent(e) {<br/>
        return (function (evtType, events) {<br/>
            switch (evtType) {<br/>
                case events.KEYDOWN:<br/>
                case events.TOUCHSTART:<br/>
                case events.POINTERDOWN:<br/>
                    this.onKeyDown(e);<br/>
                    break;<br/>
                case events.KEYUP:<br/>
                case events.TOUCHEND:<br/>
                case events.POINTERUP:<br/>
                    this.onKeyUp(e);<br/>
                    break;<br/>
                case events.GAMEPADCONNECTED:<br/>
                    this.onGamepadConnected(e);<br/>
                    break;<br/>
            }<br/>
        }.bind(this))(e.type, Runner.events);<br/>
    },<br/>
    /**<br/>
     * Initialize audio cues if activated by focus on the canvas element.<br/>
     * @param {Event} e<br/>
     */<br/>
    handleCanvasKeyPress(e) {<br/>
        if (!this.activated && !Runner.audioCues) {<br/>
            this.toggleSpeed();<br/>
            Runner.audioCues = true;<br/>
            this.generatedSoundFx.init();<br/>
            Runner.generatedSoundFx = this.generatedSoundFx;<br/>
            Runner.config.CLEAR_TIME *= 1.2;<br/>
        }<br/>
        else if (e.keyCode && Runner.keycodes.JUMP[e.keyCode]) {<br/>
            this.onKeyDown(e);<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Prevent space key press from scrolling.<br/>
     * @param {Event} e<br/>
     */<br/>
    preventScrolling(e) {<br/>
        if (e.keyCode === 32) {<br/>
            e.preventDefault();<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Toggle speed setting if toggle is shown.<br/>
     */<br/>
    toggleSpeed() {<br/>
        if (Runner.audioCues) {<br/>
            const speedChange = Runner.slowDown !== this.slowSpeedCheckbox.checked;<br/>
            if (speedChange) {<br/>
                Runner.slowDown = this.slowSpeedCheckbox.checked;<br/>
                const updatedConfig = Runner.slowDown ? Runner.slowConfig : Runner.normalConfig;<br/>
                Runner.config = Object.assign(Runner.config, updatedConfig);<br/>
                this.currentSpeed = updatedConfig.SPEED;<br/>
                this.tRex.enableSlowConfig();<br/>
                this.horizon.adjustObstacleSpeed();<br/>
            }<br/>
            if (this.playing) {<br/>
                this.disableSpeedToggle(true);<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Show the speed toggle.<br/>
     * From focus event or when audio cues are activated.<br/>
     * @param {Event=} e<br/>
     */<br/>
    showSpeedToggle(e) {<br/>
        const isFocusEvent = e && e.type === 'focus';<br/>
        if (Runner.audioCues || isFocusEvent) {<br/>
            this.slowSpeedCheckboxLabel.classList.toggle(HIDDEN_CLASS, isFocusEvent ? false : !this.crashed);<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Disable the speed toggle.<br/>
     * @param {boolean} disable<br/>
     */<br/>
    disableSpeedToggle(disable) {<br/>
        if (disable) {<br/>
            this.slowSpeedCheckbox.setAttribute('disabled', 'disabled');<br/>
        }<br/>
        else {<br/>
            this.slowSpeedCheckbox.removeAttribute('disabled');<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Bind relevant key / mouse / touch listeners.<br/>
     */<br/>
    startListening() {<br/>
        // A11y keyboard / screen reader activation.<br/>
        this.containerEl.addEventListener(Runner.events.KEYDOWN, this.handleCanvasKeyPress.bind(this));<br/>
        if (!IS_MOBILE) {<br/>
            this.containerEl.addEventListener(Runner.events.FOCUS, this.showSpeedToggle.bind(this));<br/>
        }<br/>
        this.canvas.addEventListener(Runner.events.KEYDOWN, this.preventScrolling.bind(this));<br/>
        this.canvas.addEventListener(Runner.events.KEYUP, this.preventScrolling.bind(this));<br/>
        // Keys.<br/>
        document.addEventListener(Runner.events.KEYDOWN, this);<br/>
        document.addEventListener(Runner.events.KEYUP, this);<br/>
        // Touch / pointer.<br/>
        this.containerEl.addEventListener(Runner.events.TOUCHSTART, this);<br/>
        document.addEventListener(Runner.events.POINTERDOWN, this);<br/>
        document.addEventListener(Runner.events.POINTERUP, this);<br/>
        if (this.isArcadeMode()) {<br/>
            // Gamepad<br/>
            window.addEventListener(Runner.events.GAMEPADCONNECTED, this);<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Remove all listeners.<br/>
     */<br/>
    stopListening() {<br/>
        document.removeEventListener(Runner.events.KEYDOWN, this);<br/>
        document.removeEventListener(Runner.events.KEYUP, this);<br/>
        if (this.touchController) {<br/>
            this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);<br/>
            this.touchController.removeEventListener(Runner.events.TOUCHEND, this);<br/>
        }<br/>
        this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);<br/>
        document.removeEventListener(Runner.events.POINTERDOWN, this);<br/>
        document.removeEventListener(Runner.events.POINTERUP, this);<br/>
        if (this.isArcadeMode()) {<br/>
            window.removeEventListener(Runner.events.GAMEPADCONNECTED, this);<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Process keydown.<br/>
     * @param {Event} e<br/>
     */<br/>
    onKeyDown(e) {<br/>
        // Prevent native page scrolling whilst tapping on mobile.<br/>
        if (IS_MOBILE && this.playing) {<br/>
            e.preventDefault();<br/>
        }<br/>
        if (this.isCanvasInView()) {<br/>
            // Allow toggling of speed toggle.<br/>
            if (Runner.keycodes.JUMP[e.keyCode] &&<br/>
                e.target === this.slowSpeedCheckbox) {<br/>
                return;<br/>
            }<br/>
            if (!this.crashed && !this.paused) {<br/>
                // For a11y, screen reader activation.<br/>
                const isMobileMouseInput = IS_MOBILE &&<br/>
                    e.type === Runner.events.POINTERDOWN && e.pointerType === 'mouse' &&<br/>
                    (e.target === this.containerEl ||<br/>
                        (IS_IOS &&<br/>
                            (e.target === this.touchController || e.target === this.canvas)));<br/>
                if (Runner.keycodes.JUMP[e.keyCode] ||<br/>
                    e.type === Runner.events.TOUCHSTART || isMobileMouseInput) {<br/>
                    e.preventDefault();<br/>
                    // Starting the game for the first time.<br/>
                    if (!this.playing) {<br/>
                        // Started by touch so create a touch controller.<br/>
                        if (!this.touchController && e.type === Runner.events.TOUCHSTART) {<br/>
                            this.createTouchController();<br/>
                        }<br/>
                        if (isMobileMouseInput) {<br/>
                            this.handleCanvasKeyPress(e);<br/>
                        }<br/>
                        this.loadSounds();<br/>
                        this.setPlayStatus(true);<br/>
                        this.update();<br/>
                        if (window.errorPageController) {<br/>
                            errorPageController.trackEasterEgg();<br/>
                        }<br/>
                    }<br/>
                    // Start jump.<br/>
                    if (!this.tRex.jumping && !this.tRex.ducking) {<br/>
                        if (Runner.audioCues) {<br/>
                            this.generatedSoundFx.cancelFootSteps();<br/>
                        }<br/>
                        else {<br/>
                            this.playSound(this.soundFx.BUTTON_PRESS);<br/>
                        }<br/>
                        this.tRex.startJump(this.currentSpeed);<br/>
                    }<br/>
                }<br/>
                else if (this.playing && Runner.keycodes.DUCK[e.keyCode]) {<br/>
                    e.preventDefault();<br/>
                    if (this.tRex.jumping) {<br/>
                        // Speed drop, activated only when jump key is not pressed.<br/>
                        this.tRex.setSpeedDrop();<br/>
                    }<br/>
                    else if (!this.tRex.jumping && !this.tRex.ducking) {<br/>
                        // Duck.<br/>
                        this.tRex.setDuck(true);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Process key up.<br/>
     * @param {Event} e<br/>
     */<br/>
    onKeyUp(e) {<br/>
        const keyCode = String(e.keyCode);<br/>
        const isjumpKey = Runner.keycodes.JUMP[keyCode] ||<br/>
            e.type === Runner.events.TOUCHEND || e.type === Runner.events.POINTERUP;<br/>
        if (this.isRunning() && isjumpKey) {<br/>
            this.tRex.endJump();<br/>
        }<br/>
        else if (Runner.keycodes.DUCK[keyCode]) {<br/>
            this.tRex.speedDrop = false;<br/>
            this.tRex.setDuck(false);<br/>
        }<br/>
        else if (this.crashed) {<br/>
            // Check that enough time has elapsed before allowing jump key to restart.<br/>
            const deltaTime = getTimeStamp() - this.time;<br/>
            if (this.isCanvasInView() &&<br/>
                (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||<br/>
                    (deltaTime &gt;= this.config.GAMEOVER_CLEAR_TIME &&<br/>
                        Runner.keycodes.JUMP[keyCode]))) {<br/>
                this.handleGameOverClicks(e);<br/>
            }<br/>
        }<br/>
        else if (this.paused && isjumpKey) {<br/>
            // Reset the jump state<br/>
            this.tRex.reset();<br/>
            this.play();<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Process gamepad connected event.<br/>
     * @param {Event} e<br/>
     */<br/>
    onGamepadConnected(e) {<br/>
        if (!this.pollingGamepads) {<br/>
            this.pollGamepadState();<br/>
        }<br/>
    },<br/>
    /**<br/>
     * rAF loop for gamepad polling.<br/>
     */<br/>
    pollGamepadState() {<br/>
        const gamepads = navigator.getGamepads();<br/>
        this.pollActiveGamepad(gamepads);<br/>
        this.pollingGamepads = true;<br/>
        requestAnimationFrame(this.pollGamepadState.bind(this));<br/>
    },<br/>
    /**<br/>
     * Polls for a gamepad with the jump button pressed. If one is found this<br/>
     * becomes the "active" gamepad and all others are ignored.<br/>
     * @param {!Array&lt;Gamepad&gt;} gamepads<br/>
     */<br/>
    pollForActiveGamepad(gamepads) {<br/>
        for (let i = 0; i &lt; gamepads.length; ++i) {<br/>
            if (gamepads[i] && gamepads[i].buttons.length &gt; 0 &&<br/>
                gamepads[i].buttons[0].pressed) {<br/>
                this.gamepadIndex = i;<br/>
                this.pollActiveGamepad(gamepads);<br/>
                return;<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Polls the chosen gamepad for button presses and generates KeyboardEvents<br/>
     * to integrate with the rest of the game logic.<br/>
     * @param {!Array&lt;Gamepad&gt;} gamepads<br/>
     */<br/>
    pollActiveGamepad(gamepads) {<br/>
        if (this.gamepadIndex === undefined) {<br/>
            this.pollForActiveGamepad(gamepads);<br/>
            return;<br/>
        }<br/>
        const gamepad = gamepads[this.gamepadIndex];<br/>
        if (!gamepad) {<br/>
            this.gamepadIndex = undefined;<br/>
            this.pollForActiveGamepad(gamepads);<br/>
            return;<br/>
        }<br/>
        // The gamepad specification defines the typical mapping of physical buttons<br/>
        // to button indicies: https://w3c.github.io/gamepad/#remapping<br/>
        this.pollGamepadButton(gamepad, 0, 38); // Jump<br/>
        if (gamepad.buttons.length &gt;= 2) {<br/>
            this.pollGamepadButton(gamepad, 1, 40); // Duck<br/>
        }<br/>
        if (gamepad.buttons.length &gt;= 10) {<br/>
            this.pollGamepadButton(gamepad, 9, 13); // Restart<br/>
        }<br/>
        this.previousGamepad = gamepad;<br/>
    },<br/>
    /**<br/>
     * Generates a key event based on a gamepad button.<br/>
     * @param {!Gamepad} gamepad<br/>
     * @param {number} buttonIndex<br/>
     * @param {number} keyCode<br/>
     */<br/>
    pollGamepadButton(gamepad, buttonIndex, keyCode) {<br/>
        const state = gamepad.buttons[buttonIndex].pressed;<br/>
        let previousState = false;<br/>
        if (this.previousGamepad) {<br/>
            previousState = this.previousGamepad.buttons[buttonIndex].pressed;<br/>
        }<br/>
        // Generate key events on the rising and falling edge of a button press.<br/>
        if (state !== previousState) {<br/>
            const e = new KeyboardEvent(state ? Runner.events.KEYDOWN : Runner.events.KEYUP, { keyCode: keyCode });<br/>
            document.dispatchEvent(e);<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Handle interactions on the game over screen state.<br/>
     * A user is able to tap the high score twice to reset it.<br/>
     * @param {Event} e<br/>
     */<br/>
    handleGameOverClicks(e) {<br/>
        if (e.target !== this.slowSpeedCheckbox) {<br/>
            e.preventDefault();<br/>
            if (this.distanceMeter.hasClickedOnHighScore(e) && this.highestScore) {<br/>
                if (this.distanceMeter.isHighScoreFlashing()) {<br/>
                    // Subsequent click, reset the high score.<br/>
                    this.saveHighScore(0, true);<br/>
                    this.distanceMeter.resetHighScore();<br/>
                }<br/>
                else {<br/>
                    // First click, flash the high score.<br/>
                    this.distanceMeter.startHighScoreFlashing();<br/>
                }<br/>
            }<br/>
            else {<br/>
                this.distanceMeter.cancelHighScoreFlashing();<br/>
                this.restart();<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Returns whether the event was a left click on canvas.<br/>
     * On Windows right click is registered as a click.<br/>
     * @param {Event} e<br/>
     * @return {boolean}<br/>
     */<br/>
    isLeftClickOnCanvas(e) {<br/>
        return e.button != null && e.button &lt; 2 &&<br/>
            e.type === Runner.events.POINTERUP &&<br/>
            (e.target === this.canvas ||<br/>
                (IS_MOBILE && Runner.audioCues && e.target === this.containerEl));<br/>
    },<br/>
    /**<br/>
     * RequestAnimationFrame wrapper.<br/>
     */<br/>
    scheduleNextUpdate() {<br/>
        if (!this.updatePending) {<br/>
            this.updatePending = true;<br/>
            this.raqId = requestAnimationFrame(this.update.bind(this));<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Whether the game is running.<br/>
     * @return {boolean}<br/>
     */<br/>
    isRunning() {<br/>
        return !!this.raqId;<br/>
    },<br/>
    /**<br/>
     * Set the initial high score as stored in the user's profile.<br/>
     * @param {number} highScore<br/>
     */<br/>
    initializeHighScore(highScore) {<br/>
        this.syncHighestScore = true;<br/>
        highScore = Math.ceil(highScore);<br/>
        if (highScore &lt; this.highestScore) {<br/>
            if (window.errorPageController) {<br/>
                errorPageController.updateEasterEggHighScore(this.highestScore);<br/>
            }<br/>
            return;<br/>
        }<br/>
        this.highestScore = highScore;<br/>
        this.distanceMeter.setHighScore(this.highestScore);<br/>
    },<br/>
    /**<br/>
     * Sets the current high score and saves to the profile if available.<br/>
     * @param {number} distanceRan Total distance ran.<br/>
     * @param {boolean=} opt_resetScore Whether to reset the score.<br/>
     */<br/>
    saveHighScore(distanceRan, opt_resetScore) {<br/>
        this.highestScore = Math.ceil(distanceRan);<br/>
        this.distanceMeter.setHighScore(this.highestScore);<br/>
        // Store the new high score in the profile.<br/>
        if (this.syncHighestScore && window.errorPageController) {<br/>
            if (opt_resetScore) {<br/>
                errorPageController.resetEasterEggHighScore();<br/>
            }<br/>
            else {<br/>
                errorPageController.updateEasterEggHighScore(this.highestScore);<br/>
            }<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Game over state.<br/>
     */<br/>
    gameOver() {<br/>
        this.playSound(this.soundFx.HIT);<br/>
        vibrate(200);<br/>
        this.stop();<br/>
        this.crashed = true;<br/>
        this.distanceMeter.achievement = false;<br/>
        this.tRex.update(100, Trex.status.CRASHED);<br/>
        // Game over panel.<br/>
        if (!this.gameOverPanel) {<br/>
            const origSpriteDef = IS_HIDPI ? spriteDefinitionByType.original.HDPI :<br/>
                spriteDefinitionByType.original.LDPI;<br/>
            if (this.canvas) {<br/>
                if (Runner.isAltGameModeEnabled) {<br/>
                    this.gameOverPanel = new GameOverPanel(this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART, this.dimensions, origSpriteDef.ALT_GAME_END, this.altGameModeActive);<br/>
                }<br/>
                else {<br/>
                    this.gameOverPanel = new GameOverPanel(this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART, this.dimensions);<br/>
                }<br/>
            }<br/>
        }<br/>
        this.gameOverPanel.draw(this.altGameModeActive, this.tRex);<br/>
        // Update the high score.<br/>
        if (this.distanceRan &gt; this.highestScore) {<br/>
            this.saveHighScore(this.distanceRan);<br/>
        }<br/>
        // Reset the time clock.<br/>
        this.time = getTimeStamp();<br/>
        if (Runner.audioCues) {<br/>
            this.generatedSoundFx.stopAll();<br/>
            announcePhrase(getA11yString(A11Y_STRINGS.gameOver)<br/>
                .replace('$1', this.distanceMeter.getActualDistance(this.distanceRan)<br/>
                .toString()) +<br/>
                ' ' +<br/>
                getA11yString(A11Y_STRINGS.highScore)<br/>
                    .replace('$1', this.distanceMeter.getActualDistance(this.highestScore)<br/>
                    .toString()));<br/>
            this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.ariaLabel));<br/>
        }<br/>
        this.showSpeedToggle();<br/>
        this.disableSpeedToggle(false);<br/>
    },<br/>
    stop() {<br/>
        this.setPlayStatus(false);<br/>
        this.paused = true;<br/>
        cancelAnimationFrame(this.raqId);<br/>
        this.raqId = 0;<br/>
        this.generatedSoundFx.stopAll();<br/>
    },<br/>
    play() {<br/>
        if (!this.crashed) {<br/>
            this.setPlayStatus(true);<br/>
            this.paused = false;<br/>
            this.tRex.update(0, Trex.status.RUNNING);<br/>
            this.time = getTimeStamp();<br/>
            this.update();<br/>
            this.generatedSoundFx.background();<br/>
        }<br/>
    },<br/>
    restart() {<br/>
        if (!this.raqId) {<br/>
            this.playCount++;<br/>
            this.runningTime = 0;<br/>
            this.setPlayStatus(true);<br/>
            this.toggleSpeed();<br/>
            this.paused = false;<br/>
            this.crashed = false;<br/>
            this.distanceRan = 0;<br/>
            this.setSpeed(this.config.SPEED);<br/>
            this.time = getTimeStamp();<br/>
            this.containerEl.classList.remove(Runner.classes.CRASHED);<br/>
            this.clearCanvas();<br/>
            this.distanceMeter.reset();<br/>
            this.horizon.reset();<br/>
            this.tRex.reset();<br/>
            this.playSound(this.soundFx.BUTTON_PRESS);<br/>
            this.invert(true);<br/>
            this.flashTimer = null;<br/>
            this.update();<br/>
            this.gameOverPanel.reset();<br/>
            this.generatedSoundFx.background();<br/>
            this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump));<br/>
            announcePhrase(getA11yString(A11Y_STRINGS.started));<br/>
        }<br/>
    },<br/>
    setPlayStatus(isPlaying) {<br/>
        if (this.touchController) {<br/>
            this.touchController.classList.toggle(HIDDEN_CLASS, !isPlaying);<br/>
        }<br/>
        this.playing = isPlaying;<br/>
    },<br/>
    /**<br/>
     * Whether the game should go into arcade mode.<br/>
     * @return {boolean}<br/>
     */<br/>
    isArcadeMode() {<br/>
        // In RTL languages the title is wrapped with the left to right mark<br/>
        // control characters &#x202A; and &#x202C but are invisible.<br/>
        return IS_RTL ? document.title.indexOf(ARCADE_MODE_URL) === 1 :<br/>
            document.title === ARCADE_MODE_URL;<br/>
    },<br/>
    /**<br/>
     * Hides offline messaging for a fullscreen game only experience.<br/>
     */<br/>
    setArcadeMode() {<br/>
        document.body.classList.add(Runner.classes.ARCADE_MODE);<br/>
        this.setArcadeModeContainerScale();<br/>
    },<br/>
    /**<br/>
     * Sets the scaling for arcade mode.<br/>
     */<br/>
    setArcadeModeContainerScale() {<br/>
        const windowHeight = window.innerHeight;<br/>
        const scaleHeight = windowHeight / this.dimensions.HEIGHT;<br/>
        const scaleWidth = window.innerWidth / this.dimensions.WIDTH;<br/>
        const scale = Math.max(1, Math.min(scaleHeight, scaleWidth));<br/>
        const scaledCanvasHeight = this.dimensions.HEIGHT * scale;<br/>
        // Positions the game container at 10% of the available vertical window<br/>
        // height minus the game container height.<br/>
        const translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -<br/>
            Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *<br/>
            Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *<br/>
            window.devicePixelRatio;<br/>
        const cssScale = IS_RTL ? -scale + ',' + scale : scale;<br/>
        this.containerEl.style.transform =<br/>
            'scale(' + cssScale + ') translateY(' + translateY + 'px)';<br/>
    },<br/>
    /**<br/>
     * Pause the game if the tab is not in focus.<br/>
     */<br/>
    onVisibilityChange(e) {<br/>
        if (document.hidden || document.webkitHidden || e.type === 'blur' ||<br/>
            document.visibilityState !== 'visible') {<br/>
            this.stop();<br/>
        }<br/>
        else if (!this.crashed) {<br/>
            this.tRex.reset();<br/>
            this.play();<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Play a sound.<br/>
     * @param {AudioBuffer} soundBuffer<br/>
     */<br/>
    playSound(soundBuffer) {<br/>
        if (soundBuffer) {<br/>
            const sourceNode = this.audioContext.createBufferSource();<br/>
            sourceNode.buffer = soundBuffer;<br/>
            sourceNode.connect(this.audioContext.destination);<br/>
            sourceNode.start(0);<br/>
        }<br/>
    },<br/>
    /**<br/>
     * Inverts the current page / canvas colors.<br/>
     * @param {boolean} reset Whether to reset colors.<br/>
     */<br/>
    invert(reset) {<br/>
        const htmlEl = document.firstElementChild;<br/>
        if (reset) {<br/>
            htmlEl.classList.toggle(Runner.classes.INVERTED, false);<br/>
            this.invertTimer = 0;<br/>
            this.inverted = false;<br/>
        }<br/>
        else {<br/>
            this.inverted =<br/>
                htmlEl.classList.toggle(Runner.classes.INVERTED, this.invertTrigger);<br/>
        }<br/>
    },<br/>
};<br/>
/**<br/>
 * Updates the canvas size taking into<br/>
 * account the backing store pixel ratio and<br/>
 * the device pixel ratio.<br/>
 *<br/>
 * See article by Paul Lewis:<br/>
 * http://www.html5rocks.com/en/tutorials/canvas/hidpi/<br/>
 *<br/>
 * @param {HTMLCanvasElement} canvas<br/>
 * @param {number=} opt_width<br/>
 * @param {number=} opt_height<br/>
 * @return {boolean} Whether the canvas was scaled.<br/>
 */<br/>
Runner.updateCanvasScaling = function (canvas, opt_width, opt_height) {<br/>
    const context = <br/>
    /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));<br/>
    // Query the various pixel ratios<br/>
    const devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;<br/>
    /** @suppress {missingProperties} */<br/>
    const backingStoreRatio = Math.floor(context.webkitBackingStorePixelRatio) || 1;<br/>
    const ratio = devicePixelRatio / backingStoreRatio;<br/>
    // Upscale the canvas if the two ratios don't match<br/>
    if (devicePixelRatio !== backingStoreRatio) {<br/>
        const oldWidth = opt_width || canvas.width;<br/>
        const oldHeight = opt_height || canvas.height;<br/>
        canvas.width = oldWidth * ratio;<br/>
        canvas.height = oldHeight * ratio;<br/>
        canvas.style.width = oldWidth + 'px';<br/>
        canvas.style.height = oldHeight + 'px';<br/>
        // Scale the context to counter the fact that we've manually scaled<br/>
        // our canvas element.<br/>
        context.scale(ratio, ratio);<br/>
        return true;<br/>
    }<br/>
    else if (devicePixelRatio === 1) {<br/>
        // Reset the canvas width / height. Fixes scaling bug when the page is<br/>
        // zoomed and the devicePixelRatio changes accordingly.<br/>
        canvas.style.width = canvas.width + 'px';<br/>
        canvas.style.height = canvas.height + 'px';<br/>
    }<br/>
    return false;<br/>
};<br/>
/**<br/>
 * Whether events are enabled.<br/>
 * @return {boolean}<br/>
 */<br/>
Runner.isAltGameModeEnabled = function () {<br/>
    return loadTimeData && loadTimeData.valueExists('enableAltGameMode');<br/>
};<br/>
/**<br/>
 * For screen readers make an announcement to the live region.<br/>
 * @param {string} phrase Sentence to speak.<br/>
 */<br/>
function announcePhrase(phrase) {<br/>
    if (Runner.a11yStatusEl) {<br/>
        Runner.a11yStatusEl.textContent = '';<br/>
        Runner.a11yStatusEl.textContent = phrase;<br/>
    }<br/>
}<br/>
/**<br/>
 * Returns a string from loadTimeData data object.<br/>
 * @param {string} stringName<br/>
 * @return {string}<br/>
 */<br/>
function getA11yString(stringName) {<br/>
    return loadTimeData && loadTimeData.valueExists(stringName) ?<br/>
        loadTimeData.getString(stringName) :<br/>
        '';<br/>
}<br/>
/**<br/>
 * Vibrate on mobile devices.<br/>
 * @param {number} duration Duration of the vibration in milliseconds.<br/>
 */<br/>
function vibrate(duration) {<br/>
    if (IS_MOBILE && window.navigator.vibrate) {<br/>
        window.navigator.vibrate(duration);<br/>
    }<br/>
}<br/>
/**<br/>
 * Create canvas element.<br/>
 * @param {Element} container Element to append canvas to.<br/>
 * @param {number} width<br/>
 * @param {number} height<br/>
 * @param {string=} opt_classname<br/>
 * @return {HTMLCanvasElement}<br/>
 */<br/>
function createCanvas(container, width, height, opt_classname) {<br/>
    const canvas = <br/>
    /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));<br/>
    canvas.className = Runner.classes.CANVAS;<br/>
    canvas.width = width;<br/>
    canvas.height = height;<br/>
    container.appendChild(canvas);<br/>
    return canvas;<br/>
}<br/>
/**<br/>
 * Decodes the base 64 audio to ArrayBuffer used by Web Audio.<br/>
 * @param {string} base64String<br/>
 */<br/>
function decodeBase64ToArrayBuffer(base64String) {<br/>
    const len = (base64String.length / 4) * 3;<br/>
    const str = atob(base64String);<br/>
    const arrayBuffer = new ArrayBuffer(len);<br/>
    const bytes = new Uint8Array(arrayBuffer);<br/>
    for (let i = 0; i &lt; len; i++) {<br/>
        bytes[i] = str.charCodeAt(i);<br/>
    }<br/>
    return bytes.buffer;<br/>
}<br/>
//******************************************************************************<br/>
/**<br/>
 * Check for a collision.<br/>
 * @param {!Obstacle} obstacle<br/>
 * @param {!Trex} tRex T-rex object.<br/>
 * @param {CanvasRenderingContext2D=} opt_canvasCtx Optional canvas context for<br/>
 *    drawing collision boxes.<br/>
 * @return {Array&lt;CollisionBox&gt;|undefined}<br/>
 */<br/>
function checkForCollision(obstacle, tRex, opt_canvasCtx) {<br/>
    Runner.defaultDimensions.WIDTH + obstacle.xPos;<br/>
    // Adjustments are made to the bounding box as there is a 1 pixel white<br/>
    // border around the t-rex and obstacles.<br/>
    const tRexBox = new CollisionBox(tRex.xPos + 1, tRex.yPos + 1, tRex.config.WIDTH - 2, tRex.config.HEIGHT - 2);<br/>
    const obstacleBox = new CollisionBox(obstacle.xPos + 1, obstacle.yPos + 1, obstacle.typeConfig.width * obstacle.size - 2, obstacle.typeConfig.height - 2);<br/>
    // Simple outer bounds check.<br/>
    if (boxCompare(tRexBox, obstacleBox)) {<br/>
        const collisionBoxes = obstacle.collisionBoxes;<br/>
        let tRexCollisionBoxes = [];<br/>
        if (Runner.isAltGameModeEnabled()) {<br/>
            tRexCollisionBoxes = Runner.spriteDefinition.TREX.COLLISION_BOXES;<br/>
        }<br/>
        else {<br/>
            tRexCollisionBoxes = tRex.ducking ? Trex.collisionBoxes.DUCKING :<br/>
                Trex.collisionBoxes.RUNNING;<br/>
        }<br/>
        // Detailed axis aligned box check.<br/>
        for (let t = 0; t &lt; tRexCollisionBoxes.length; t++) {<br/>
            for (let i = 0; i &lt; collisionBoxes.length; i++) {<br/>
                // Adjust the box to actual positions.<br/>
                const adjTrexBox = createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);<br/>
                const adjObstacleBox = createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);<br/>
                const crashed = boxCompare(adjTrexBox, adjObstacleBox);<br/>
                if (crashed) {<br/>
                    return [adjTrexBox, adjObstacleBox];<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
}<br/>
/**<br/>
 * Adjust the collision box.<br/>
 * @param {!CollisionBox} box The original box.<br/>
 * @param {!CollisionBox} adjustment Adjustment box.<br/>
 * @return {CollisionBox} The adjusted collision box object.<br/>
 */<br/>
function createAdjustedCollisionBox(box, adjustment) {<br/>
    return new CollisionBox(box.x + adjustment.x, box.y + adjustment.y, box.width, box.height);<br/>
}<br/>
/**<br/>
 * Compare two collision boxes for a collision.<br/>
 * @param {CollisionBox} tRexBox<br/>
 * @param {CollisionBox} obstacleBox<br/>
 * @return {boolean} Whether the boxes intersected.<br/>
 */<br/>
function boxCompare(tRexBox, obstacleBox) {<br/>
    let crashed = false;<br/>
    tRexBox.x;<br/>
    tRexBox.y;<br/>
    const obstacleBoxX = obstacleBox.x;<br/>
    obstacleBox.y;<br/>
    // Axis-Aligned Bounding Box method.<br/>
    if (tRexBox.x &lt; obstacleBoxX + obstacleBox.width &&<br/>
        tRexBox.x + tRexBox.width &gt; obstacleBoxX &&<br/>
        tRexBox.y &lt; obstacleBox.y + obstacleBox.height &&<br/>
        tRexBox.height + tRexBox.y &gt; obstacleBox.y) {<br/>
        crashed = true;<br/>
    }<br/>
    return crashed;<br/>
}<br/>
<br/>
// Copyright 2013 The Chromium Authors<br/>
// Use of this source code is governed by a BSD-style license that can be<br/>
// found in the LICENSE file.<br/>
let showingDetails = false;<br/>
let lastData = null;<br/>
function toggleHelpBox() {<br/>
    showingDetails = !showingDetails;<br/>
    assert(lastData);<br/>
    j(getHtml(lastData, showingDetails), getRequiredElement('content'));<br/>
}<br/>
function diagnoseErrors() {<br/>
    if (window.errorPageController) {<br/>
        window.errorPageController.diagnoseErrorsButtonClick();<br/>
    }<br/>
}<br/>
function portalSignin() {<br/>
    if (window.errorPageController) {<br/>
        window.errorPageController.portalSigninButtonClick();<br/>
    }<br/>
}<br/>
// Subframes use a different layout but the same html file.  This is to make it<br/>
// easier to support platforms that load the error page via different<br/>
// mechanisms (Currently just iOS).<br/>
let isSubFrame = false;<br/>
if (window.top.location !== window.location) {<br/>
    document.documentElement.setAttribute('subframe', '');<br/>
    isSubFrame = true;<br/>
}<br/>
// Re-renders the error page using |data| as the dictionary of values.<br/>
// Used by NetErrorTabHelper to update DNS error pages with probe results.<br/>
function updateForDnsProbe(newData) {<br/>
    onTemplateDataReceived(newData);<br/>
}<br/>
function getMainFrameErrorCssClass(showingDetails) {<br/>
    return showingDetails ? 'showing-details' : '';<br/>
}<br/>
function getMainFrameErrorIconCssClass(data) {<br/>
    return isSubFrame ? '' : data.iconClass;<br/>
}<br/>
function getSubFrameErrorIconCssClass(data) {<br/>
    return isSubFrame ? data.iconClass : '';<br/>
}<br/>
function shouldShowSuggestionsSummaryList(data) {<br/>
    return !!data.suggestionsSummaryList &&<br/>
        data.suggestionsSummaryList.length &gt; 0;<br/>
}<br/>
function getSuggestionsSummaryItemCssClass(data) {<br/>
    assert(data.suggestionsSummaryList);<br/>
    return data.suggestionsSummaryList.length === 1 ? 'single-suggestion' : '';<br/>
}<br/>
// Implements button clicks.  This function is needed during the transition<br/>
// between implementing these in trunk chromium and implementing them in iOS.<br/>
function reloadButtonClick(e) {<br/>
    const url = e.target.dataset['url'];<br/>
    if (window.errorPageController) {<br/>
        // <br/>
        // <br/>
        window.errorPageController.reloadButtonClick();<br/>
        // <br/>
    }<br/>
    else {<br/>
        assert(url);<br/>
        window.location.href = url;<br/>
    }<br/>
}<br/>
function downloadButtonClick() {<br/>
    if (window.errorPageController) {<br/>
        window.errorPageController.downloadButtonClick();<br/>
        const downloadButton = getRequiredElement('download-button');<br/>
        downloadButton.disabled = true;<br/>
        downloadButton.textContent = downloadButton.disabledText;<br/>
    }<br/>
}<br/>
function detailsButtonClick() {<br/>
    if (window.errorPageController) {<br/>
        window.errorPageController.detailsButtonClick();<br/>
    }<br/>
    toggleHelpBox();<br/>
}<br/>
function setAutoFetchState(scheduled, canSchedule) {<br/>
    getRequiredElement('cancel-save-page-button')<br/>
        .classList.toggle(HIDDEN_CLASS, !scheduled);<br/>
    getRequiredElement('save-page-for-later-button')<br/>
        .classList.toggle(HIDDEN_CLASS, !canSchedule);<br/>
}<br/>
function savePageLaterClick() {<br/>
    assert(window.errorPageController);<br/>
    window.errorPageController.savePageForLater();<br/>
    // savePageForLater will eventually trigger a call to setAutoFetchState() when<br/>
    // it completes.<br/>
}<br/>
function cancelSavePageClick() {<br/>
    assert(window.errorPageController);<br/>
    window.errorPageController.cancelSavePage();<br/>
    // setAutoFetchState is not called in response to cancelSavePage(), so do it<br/>
    // now.<br/>
    setAutoFetchState(false, true);<br/>
}<br/>
function shouldShowControlButtons(data) {<br/>
    const downloadButtonVisible = !!data.downloadButton && !!data.downloadButton.msg;<br/>
    const reloadButtonVisible = !!data.reloadButton && !!data.reloadButton.msg;<br/>
    return reloadButtonVisible || downloadButtonVisible;<br/>
}<br/>
function shouldShowDetailsButton(data) {<br/>
    return !!data.suggestionsDetails && data.suggestionsDetails.length &gt; 0;<br/>
}<br/>
function getDetailsButtonCssClass(data) {<br/>
    return shouldShowControlButtons(data) ? '' : 'singular';<br/>
}<br/>
function getDetailsButtonText(data, showingDetails) {<br/>
    assert(data.details);<br/>
    assert(data.hideDetails);<br/>
    return showingDetails ? data.hideDetails : data.details;<br/>
}<br/>
// Sets up the proper button layout for the current platform.<br/>
function getButtonsCssClass() {<br/>
    let primaryControlOnLeft = true;<br/>
    // clang-format off<br/>
    // <br/>
    return primaryControlOnLeft ? 'suggested-left' : 'suggested-right';<br/>
}<br/>
function onDocumentLoad() {<br/>
    onTemplateDataReceived(window.loadTimeDataRaw);<br/>
}<br/>
function onTemplateDataReceived(newData) {<br/>
    lastData = newData;<br/>
    j(getHtml(lastData, showingDetails), getRequiredElement('content'));<br/>
    if (!isSubFrame && newData.iconClass === 'icon-offline') {<br/>
        document.documentElement.classList.add('offline');<br/>
        // Set loadTimeData.data because it is used by the dino code.<br/>
        loadTimeData.data = newData;<br/>
        new Runner('.interstitial-wrapper');<br/>
    }<br/>
}<br/>
function getHtml(data, showingDetails) {<br/>
    // clang-format off<br/>
    return x `<br/>
    &lt;div id="main-frame-error" class="interstitial-wrapper ${getMainFrameErrorCssClass(showingDetails)}"&gt;<br/>
      &lt;div id="main-content"&gt;<br/>
        &lt;div class="icon ${getMainFrameErrorIconCssClass(data)}"&gt;&lt;/div&gt;<br/>
        &lt;div id="main-message"&gt;<br/>
          &lt;h1&gt;<br/>
            &lt;span .innerHTML="${data.heading.msg}"&gt;&lt;/span&gt;<br/>
          &lt;/h1&gt;<br/>
          ${data.summary ? x `<br/>
            &lt;p .innerHTML="${data.summary.msg}"&gt;&lt;/p&gt;<br/>
          ` : ''}<br/>
<br/>
          ${shouldShowSuggestionsSummaryList(data) ? x `<br/>
            &lt;div id="suggestions-list"&gt;<br/>
              &lt;p&gt;${data.suggestionsSummaryListHeader}&lt;/p&gt;<br/>
              &lt;ul class="${getSuggestionsSummaryItemCssClass(data)}"&gt;<br/>
                ${data.suggestionsSummaryList.map(item =&gt; x `<br/>
                  &lt;li .innerHTML="${item.summary}"&gt;&lt;/li&gt;<br/>
                `)}<br/>
              &lt;/ul&gt;<br/>
            &lt;/div&gt;<br/>
          ` : ''}<br/>
<br/>
          &lt;div class="error-code"&gt;${data.errorCode}&lt;/div&gt;<br/>
<br/>
          ${data.savePageLater ? x `<br/>
            &lt;div id="save-page-for-later-button"&gt;<br/>
              &lt;a class="link-button" @click="${savePageLaterClick}"&gt;<br/>
                ${data.savePageLater.savePageMsg}<br/>
              &lt;/a&gt;<br/>
            &lt;/div&gt;<br/>
            &lt;div id="cancel-save-page-button" class="hidden"<br/>
                @click="${cancelSavePageClick}"<br/>
                .innerHTML="${data.savePageLater.cancelMsg}"&gt;<br/>
            &lt;/div&gt;<br/>
          ` : ''}<br/>
        &lt;/div&gt;<br/>
      &lt;/div&gt;<br/>
      &lt;div id="buttons" class="nav-wrapper ${getButtonsCssClass()}"&gt;<br/>
        &lt;div id="control-buttons" ?hidden="${!shouldShowControlButtons(data)}"&gt;<br/>
          ${data.reloadButton ? x `<br/>
            &lt;button id="reload-button"<br/>
                class="blue-button text-button"<br/>
                @click="${reloadButtonClick}"<br/>
                data-url="${data.reloadButton.reloadUrl}"&gt;<br/>
              ${data.reloadButton.msg}<br/>
            &lt;/button&gt;<br/>
          ` : ''}<br/>
          ${data.downloadButton ? x `<br/>
            &lt;button id="download-button"<br/>
                class="blue-button text-button"<br/>
                @click="${downloadButtonClick}"<br/>
                .disabledText="${data.downloadButton.disabledMsg}"&gt;<br/>
              ${data.downloadButton.msg}<br/>
            &lt;/button&gt;<br/>
          ` : ''}<br/>
        &lt;/div&gt;<br/>
        ${shouldShowDetailsButton(data) ? x `<br/>
          &lt;button id="details-button" class="secondary-button text-button<br/>
              small-link ${getDetailsButtonCssClass(data)}"<br/>
              @click="${detailsButtonClick}"&gt;<br/>
            ${getDetailsButtonText(data, showingDetails)}<br/>
          &lt;/button&gt;<br/>
        ` : ''}<br/>
      &lt;/div&gt;<br/>
      ${data.suggestionsDetails ? x `<br/>
        &lt;div id="details"&gt;<br/>
          ${data.suggestionsDetails.map(item =&gt; x `<br/>
            &lt;div class="suggestions"&gt;<br/>
              &lt;div class="suggestion-header" .innerHTML="${item.header}"&gt;&lt;/div&gt;<br/>
              &lt;div class="suggestion-body" .innerHTML="${item.body}"&gt;&lt;/div&gt;<br/>
            &lt;/div&gt;<br/>
          `)}<br/>
        &lt;/div&gt;<br/>
      ` : ''}<br/>
    &lt;/div&gt;<br/>
    ${data.summary ? x `<br/>
      &lt;div id="sub-frame-error"&gt;<br/>
        &lt;!-- Show details when hovering over the icon, in case the details are<br/>
             hidden because they're too large. --&gt;<br/>
        &lt;div class="icon ${getSubFrameErrorIconCssClass(data)}"&gt;&lt;/div&gt;<br/>
        &lt;div id="sub-frame-error-details" .innerHTML="${data.summary.msg}"&gt;<br/>
        &lt;/div&gt;<br/>
      &lt;/div&gt;<br/>
    ` : ''}<br/>
  `;<br/>
    // clang-format on<br/>
}<br/>
// Expose methods that are triggered either<br/>
//  - By `onclick=...` handlers in the HTML code, OR<br/>
//  - By `href="javascript:..."` in localized links.<br/>
//  - By inected JS code coming from C++<br/>
//<br/>
//  since those need to be available on the 'window' object.<br/>
Object.assign(window, {<br/>
    diagnoseErrors,<br/>
    portalSignin,<br/>
    toggleHelpBox,<br/>
    updateForDnsProbe,<br/>
});<br/>
document.addEventListener('DOMContentLoaded', onDocumentLoad);<br/>
//# sourceMappingURL=neterror.rollup.js.map<br/>
&lt;/script&gt;<br/>
 &lt;/head&gt;<br/>
 &lt;body class="neterror" style="font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 75%"&gt;<br/>
  &lt;div id="content"&gt;<br/>
   &lt;!----&gt;<br/>
   &lt;div id="main-frame-error" class="interstitial-wrapper "&gt;<br/>
    &lt;div id="main-content"&gt;<br/>
     &lt;div class="icon icon-generic"&gt;&lt;/div&gt;<br/>
     &lt;div id="main-message"&gt;<br/>
      &lt;h1&gt;&lt;span&gt;No se puede acceder a este sitio&lt;/span&gt;&lt;/h1&gt;&lt;!--?lit$00842848$--&gt;<br/>
      &lt;p&gt;&lt;strong&gt;10.203.114.11&lt;/strong&gt; tard demasiado en responder.&lt;/p&gt;&lt;!--?lit$00842848$--&gt;<br/>
      &lt;div id="suggestions-list"&gt;<br/>
       &lt;p&gt;&lt;!--?lit$00842848$--&gt;Intenta:&lt;/p&gt;<br/>
       &lt;ul class=""&gt;&lt;!--?lit$00842848$--&gt;&lt;!----&gt;<br/>
        &lt;li&gt;Comprobar la conexin.&lt;/li&gt;&lt;!----&gt;&lt;!----&gt;<br/>
        &lt;li&gt;&lt;a href="#buttons" onclick="toggleHelpBox()"&gt;Comprobar el proxy y el firewall&lt;/a&gt;.&lt;/li&gt;&lt;!----&gt;&lt;!----&gt;<br/>
        &lt;li&gt;&lt;a href="javascript:diagnoseErrors()" id="diagnose-link"&gt;Ejecucin del Diagnstico de red de Windows&lt;/a&gt;&lt;/li&gt;&lt;!----&gt;<br/>
       &lt;/ul&gt;<br/>
      &lt;/div&gt;<br/>
      &lt;div class="error-code"&gt;<br/>
       &lt;!--?lit$00842848$--&gt;ERR_CONNECTION_TIMED_OUT<br/>
      &lt;/div&gt;&lt;!--?lit$00842848$--&gt;<br/>
     &lt;/div&gt;<br/>
    &lt;/div&gt;<br/>
    &lt;div id="buttons" class="nav-wrapper suggested-left"&gt;<br/>
     &lt;div id="control-buttons"&gt;&lt;!--?lit$00842848$--&gt; &lt;button id="reload-button" class="blue-button text-button" data-url="https://10.203.114.11/oc/bes/sm/login/login-colombia.html"&gt; &lt;!--?lit$00842848$--&gt;Volver a cargar &lt;/button&gt; &lt;!--?lit$00842848$--&gt;<br/>
     &lt;/div&gt;&lt;!--?lit$00842848$--&gt; &lt;button id="details-button" class="secondary-button text-button<br/>
              small-link "&gt; &lt;!--?lit$00842848$--&gt;Detalles &lt;/button&gt;<br/>
    &lt;/div&gt;&lt;!--?lit$00842848$--&gt;<br/>
    &lt;div id="details"&gt;&lt;!--?lit$00842848$--&gt;&lt;!----&gt;<br/>
     &lt;div class="suggestions"&gt;<br/>
      &lt;div class="suggestion-header"&gt;<br/>
       Comprueba tu conexin a Internet.<br/>
      &lt;/div&gt;<br/>
      &lt;div class="suggestion-body"&gt;<br/>
       Revisa los cables y reinicia los routers, mdems u otros dispositivos de red que ests usando.<br/>
      &lt;/div&gt;<br/>
     &lt;/div&gt;&lt;!----&gt;&lt;!----&gt;<br/>
     &lt;div class="suggestions"&gt;<br/>
      &lt;div class="suggestion-header"&gt;<br/>
       Permite que Chrome acceda a la red en tu configuracin de firewall o antivirus.<br/>
      &lt;/div&gt;<br/>
      &lt;div class="suggestion-body"&gt;<br/>
       Si ya est incluido como un programa con permiso para acceder a la red, intenta quitarlo de la lista y agregarlo de nuevo.<br/>
      &lt;/div&gt;<br/>
     &lt;/div&gt;&lt;!----&gt;&lt;!----&gt;<br/>
     &lt;div class="suggestions"&gt;<br/>
      &lt;div class="suggestion-header"&gt;<br/>
       Si utilizas un servidor proxy<br/>
      &lt;/div&gt;<br/>
      &lt;div class="suggestion-body"&gt;<br/>
       Accede al men de Chrome &gt; &lt;span&gt;Configuracin&lt;/span&gt; &gt; &lt;span&gt;Mostrar configuracin avanzada&lt;/span&gt; &gt; &lt;span&gt;Cambiar la configuracin del proxy&lt;/span&gt; &gt; Configuracin LAN y desmarca la casilla de verificacin "Usar un servidor proxy para tu LAN".<br/>
      &lt;/div&gt;<br/>
     &lt;/div&gt;&lt;!----&gt;<br/>
    &lt;/div&gt;<br/>
   &lt;/div&gt;&lt;!--?lit$00842848$--&gt;<br/>
   &lt;div id="sub-frame-error"&gt;&lt;!-- Show details when hovering over the icon, in case the details are<br/>
             hidden because they're too large. --&gt;<br/>
    &lt;div class="icon "&gt;&lt;/div&gt;<br/>
    &lt;div id="sub-frame-error-details"&gt;<br/>
     &lt;strong&gt;10.203.114.11&lt;/strong&gt; tard demasiado en responder.<br/>
    &lt;/div&gt;<br/>
   &lt;/div&gt;<br/>
  &lt;/div&gt;<br/>
  &lt;div id="offline-resources"&gt;&lt;img id="offline-resources-1x" src="data:image/png;base64,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"&gt; &lt;img id="offline-resources-2x" src="data:image/png;base64,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"&gt;<br/>
   &lt;template id="audio-resources"&gt;<br/>
    &lt;audio id="offline-sound-press" src="data:audio/mpeg;base64,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"&gt;&lt;/audio&gt;<br/>
    &lt;audio id="offline-sound-hit" src="data:audio/mpeg;base64,T2dnUwACAAAAAAAAAABVDxppAAAAABYzHfUBHgF2b3JiaXMAAAAAAkSsAAD/////AHcBAP////+4AU9nZ1MAAAAAAAAAAAAAVQ8aaQEAAAC9PVXbEEf//////////////////+IDdm9yYmlzNwAAAEFPOyBhb1R1ViBiNSBbMjAwNjEwMjRdIChiYXNlZCBvbiBYaXBoLk9yZydzIGxpYlZvcmJpcykAAAAAAQV2b3JiaXMlQkNWAQBAAAAkcxgqRqVzFoQQGkJQGeMcQs5r7BlCTBGCHDJMW8slc5AhpKBCiFsogdCQVQAAQAAAh0F4FISKQQghhCU9WJKDJz0IIYSIOXgUhGlBCCGEEEIIIYQQQgghhEU5aJKDJ0EIHYTjMDgMg+U4+ByERTlYEIMnQegghA9CuJqDrDkIIYQkNUhQgwY56ByEwiwoioLEMLgWhAQ1KIyC5DDI1IMLQoiag0k1+BqEZ0F4FoRpQQghhCRBSJCDBkHIGIRGQViSgwY5uBSEy0GoGoQqOQgfhCA0ZBUAkAAAoKIoiqIoChAasgoAyAAAEEBRFMdxHMmRHMmxHAsIDVkFAAABAAgAAKBIiqRIjuRIkiRZkiVZkiVZkuaJqizLsizLsizLMhAasgoASAAAUFEMRXEUBwgNWQUAZAAACKA4iqVYiqVoiueIjgiEhqwCAIAAAAQAABA0Q1M8R5REz1RV17Zt27Zt27Zt27Zt27ZtW5ZlGQgNWQUAQAAAENJpZqkGiDADGQZCQ1YBAAgAAIARijDEgNCQVQAAQAAAgBhKDqIJrTnfnOOgWQ6aSrE5HZxItXmSm4q5Oeecc87J5pwxzjnnnKKcWQyaCa0555zEoFkKmgmtOeecJ7F50JoqrTnnnHHO6WCcEcY555wmrXmQmo21OeecBa1pjppLsTnnnEi5eVKbS7U555xzzjnnnHPOOeec6sXpHJwTzjnnnKi9uZab0MU555xPxunenBDOOeecc84555xzzjnnnCA0ZBUAAAQAQBCGjWHcKQjS52ggRhFiGjLpQffoMAkag5xC6tHoaKSUOggllXFSSicIDVkFAAACAEAIIYUUUkghhRRSSCGFFGKIIYYYcsopp6CCSiqpqKKMMssss8wyyyyzzDrsrLMOOwwxxBBDK63EUlNtNdZYa+4555qDtFZaa621UkoppZRSCkJDVgEAIAAABEIGGWSQUUghhRRiiCmnnHIKKqiA0JBVAAAgAIAAAAAAT/Ic0REd0REd0REd0REd0fEczxElURIlURIt0zI101NFVXVl15Z1Wbd9W9iFXfd93fd93fh1YViWZVmWZVmWZVmWZVmWZVmWIDRkFQAAAgAAIIQQQkghhRRSSCnGGHPMOegklBAIDVkFAAACAAgAAABwFEdxHMmRHEmyJEvSJM3SLE/zNE8TPVEURdM0VdEVXVE3bVE2ZdM1XVM2XVVWbVeWbVu2dduXZdv3fd/3fd/3fd/3fd/3fV0HQkNWAQASAAA6kiMpkiIpkuM4jiRJQGjIKgBABgBAAACK4iiO4ziSJEmSJWmSZ3mWqJma6ZmeKqpAaMgqAAAQAEAAAAAAAACKpniKqXiKqHiO6IiSaJmWqKmaK8qm7Lqu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67quC4SGrAIAJAAAdCRHciRHUiRFUiRHcoDQkFUAgAwAgAAAHMMxJEVyLMvSNE/zNE8TPdETPdNTRVd0gdCQVQAAIACAAAAAAAAADMmwFMvRHE0SJdVSLVVTLdVSRdVTVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTdM0TRMIDVkJAJABAKAQW0utxdwJahxi0nLMJHROYhCqsQgiR7W3yjGlHMWeGoiUURJ7qihjiknMMbTQKSet1lI6hRSkmFMKFVIOWiA0ZIUAEJoB4HAcQLIsQLI0AAAAAAAAAJA0DdA8D7A8DwAAAAAAAAAkTQMsTwM0zwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQNI0QPM8QPM8AAAAAAAAANA8D/BEEfBEEQAAAAAAAAAszwM80QM8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwNE0QPM8QPM8AAAAAAAAALA8D/BEEfA8EQAAAAAAAAA0zwM8UQQ8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABDgAAAQYCEUGrIiAIgTADA4DjQNmgbPAziWBc+D50EUAY5lwfPgeRBFAAAAAAAAAAAAADTPg6pCVeGqAM3zYKpQVaguAAAAAAAAAAAAAJbnQVWhqnBdgOV5MFWYKlQVAAAAAAAAAAAAAE8UobpQXbgqwDNFuCpcFaoLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAABhwAAAIMKEMFBqyIgCIEwBwOIplAQCA4ziWBQAAjuNYFgAAWJYligAAYFmaKAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrISAIgCADAoimUBy7IsYFmWBTTNsgCWBtA8gOcBRBEACAAAKHAAAAiwQVNicYBCQ1YCAFEAAAZFsSxNE0WapmmaJoo0TdM0TRR5nqZ5nmlC0zzPNCGKnmeaEEXPM02YpiiqKhBFVRUAAFDgAAAQYIOmxOIAhYasBABCAgAMjmJZnieKoiiKpqmqNE3TPE8URdE0VdVVaZqmeZ4oiqJpqqrq8jxNE0XTFEXTVFXXhaaJommaommqquvC80TRNE1TVVXVdeF5omiapqmqruu6EEVRNE3TVFXXdV0giqZpmqrqurIMRNE0VVVVXVeWgSiapqqqquvKMjBN01RV15VdWQaYpqq6rizLMkBVXdd1ZVm2Aarquq4ry7INcF3XlWVZtm0ArivLsmzbAgAADhwAAAKMoJOMKouw0YQLD0ChISsCgCgAAMAYphRTyjAmIaQQGsYkhBJCJiWVlEqqIKRSUikVhFRSKiWjklJqKVUQUikplQpCKqWVVAAA2IEDANiBhVBoyEoAIA8AgCBGKcYYYwwyphRjzjkHlVKKMeeck4wxxphzzkkpGWPMOeeklIw555xzUkrmnHPOOSmlc84555yUUkrnnHNOSiklhM45J6WU0jnnnBMAAFTgAAAQYKPI5gQjQYWGrAQAUgEADI5jWZqmaZ4nipYkaZrneZ4omqZmSZrmeZ4niqbJ8zxPFEXRNFWV53meKIqiaaoq1xVF0zRNVVVVsiyKpmmaquq6ME3TVFXXdWWYpmmqquu6LmzbVFXVdWUZtq2aqiq7sgxcV3Vl17aB67qu7Nq2AADwBAcAoAIbVkc4KRoLLDRkJQCQAQBAGIOMQgghhRBCCiGElFIICQAAGHAAAAgwoQwUGrISAEgFAACQsdZaa6211kBHKaWUUkqpcIxSSimllFJKKaWUUkoppZRKSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoFAC5VOADoPtiwOsJJ0VhgoSErAYBUAADAGKWYck5CKRVCjDkmIaUWK4QYc05KSjEWzzkHoZTWWiyecw5CKa3FWFTqnJSUWoqtqBQyKSml1mIQwpSUWmultSCEKqnEllprQQhdU2opltiCELa2klKMMQbhg4+xlVhqDD74IFsrMdVaAABmgwMARIINqyOcFI0FFhqyEgAICQAgjFGKMcYYc8455yRjjDHmnHMQQgihZIwx55xzDkIIIZTOOeeccxBCCCGEUkrHnHMOQgghhFBS6pxzEEIIoYQQSiqdcw5CCCGEUkpJpXMQQgihhFBCSSWl1DkIIYQQQikppZRCCCGEEkIoJaWUUgghhBBCKKGklFIKIYRSQgillJRSSimFEEoIpZSSUkkppRJKCSGEUlJJKaUUQggllFJKKimllEoJoYRSSimlpJRSSiGUUEIpBQAAHDgAAAQYQScZVRZhowkXHoBCQ1YCAGQAAJSyUkoorVVAIqUYpNpCR5mDFHOJLHMMWs2lYg4pBq2GyjGlGLQWMgiZUkxKCSV1TCknLcWYSuecpJhzjaVzEAAAAEEAgICQAAADBAUzAMDgAOFzEHQCBEcbAIAgRGaIRMNCcHhQCRARUwFAYoJCLgBUWFykXVxAlwEu6OKuAyEEIQhBLA6ggAQcnHDDE294wg1O0CkqdSAAAAAAAAwA8AAAkFwAERHRzGFkaGxwdHh8gISIjJAIAAAAAAAYAHwAACQlQERENHMYGRobHB0eHyAhIiMkAQCAAAIAAAAAIIAABAQEAAAAAAACAAAABARPZ2dTAATCMAAAAAAAAFUPGmkCAAAAhlAFnjkoHh4dHx4pKHA1KjEqLzIsNDQqMCveHiYpczUpLS4sLSg3MicsLCsqJTIvJi0sKywkMjbgWVlXWUa00CqtQNVCq7QC1aoNVPXg9Xldx3nn5tixvV6vb7TX+hg7cK21QYgAtNJFphRUtpUuMqWgsqrasj2IhOA1F7LFMdFaWzkAtNBFpisIQgtdZLqCIKjqAAa9WePLkKr1MMG1FlwGtNJFTSkIcitd1JSCIKsCAQWISK0Cyzw147T1tAK00kVNKKjQVrqoCQUVqqr412m+VKtZf9h+TDaaztAAtNJFzVQQhFa6qJkKgqAqUGgtuOa2Se5l6jeXGSqnLM9enqnLs5dn6m7TptWUiVUVN4jhUz9//lzx+Xw+X3x8fCQSiWggDAA83UXF6/vpLipe3zsCULWMBE5PMTBMlsv39/f39/f39524nZ13CDgaRFuLYTbaWgyzq22MzEyKolIpst50Z9PGqqJSq8T2++taLf3+oqg6btyouhEjYlxFjXxex1wCBFxcv+PmzG1uc2bKyJFLLlkizZozZ/ZURpZs2TKiWbNnz5rKyJItS0akWbNnzdrIyJJtxmCczpxOATRRhoPimyjDQfEfIFMprQDU3WFYbXZLZZxMhxrGyRh99Uqel55XEk+9efP7I/FU/8Ojew4JNN/rTq6b73Un1x+AVSsCWD2tNqtpGOM4DOM4GV7n5th453cXNGcfAYQKTFEOguKnKAdB8btRLxNBWUrViLoY1/q1er+Q9xkvZM/IjaoRf30xu3HLnr61fu3UBDRZHZdqsjoutQeAVesAxNMTw2rR66X/Ix6/T5tx80+t/D67ipt/q5XfJzTfa03Wzfdak/UeAEpZawlsbharxTBVO1+c2nm/7/f1XR1dY8XaKWMH3aW9xvEFRFEksXgURRKLn7VamSFRVnYXg0C2Zo2MNE3+57u+e3NFlVev1uufX6nU3Lnf9d1j4wE03+sObprvdQc3ewBYFIArAtjdrRaraRivX7x+8VrbHIofG0n6cFwtNFKYBzxXA2j4uRpAw7dJRkSETBkZV1V1o+N0Op1WhmEyDOn36437RbKvl7zz838wgn295Iv8/Ac8UaRIPFGkSHyAzCItAXY3dzGsNueM6VDDOJkOY3QYX008L6vnfZp/3qf559VQL3Xm1SEFNN2fiMA03Z+IwOwBoKplAKY4TbGIec0111x99dXr9XrjZ/nzdSWXBekAHEsWp4ljyeI0sVs2FEGiLFLj7rjxeqG8Pm+tX/uW90b+DX31bVTF/I+Ut+/sM1IA/MyILvUzI7rUbpNqyIBVjSDGVV/Jo/9H6G/jq+5y3Pzb7P74Znf5ffZtApI5/fN5SAcHjIhB5vTP5yEdHDAiBt4oK/WGeqUMMspeTNsGk/H/PziIgCrG1Rijktfreh2vn4DH78WXa25yZkizZc9oM7JmaYeZM6bJOJkOxmE69Hmp/q/k0fvVRLln3H6fXcXNPt78W638Ptlxsytv/pHyW7Pfp1Xc7L5XfqvZb5MdN7vy5p/u8lut/D6t4mb3vfmnVn6bNt9nV3Hzj1d+q9lv02bc7Mqbf6vZb+N23OzKm73u8lOz3+fY3uwqLv1022+THTepN38yf7XyW1aX8YqjACWfDTiAA+BQALTURU0oCFpLXdSEgqAJpAKxrLtzybNt1Go5VeJAASzRnh75Eu3pke8BYNWiCIBVLdgsXMqlXBJijDGW2Sj5lUqlSJFpPN9fAf08318B/ewBUMUiA3h4YGIaooZrfn5+fn5+fn5+fn6mtQYKcQE8WVg5YfJkYeWEyWqblCIiiqKoVGq1WqxWWa3X6/V6vVoty0zrptXq9/u4ccS4GjWKGxcM6ogaNWpUnoDf73Xd3OQml2xZMhJNM7Nmz54zZ/bsWbNmphVJRpYs2bJly5YtS0YSoWlm1uzZc+bMnj17ZloATNNI4PbTNBK4/W5jlJGglFJWI4hR/levXr06RuJ5+fLly6Ln1atXxxD18uXLKnr+V8cI8/M03+vErpvvdWLXewBYxVoC9bBZDcPU3Bevtc399UWNtZH0p4MJZov7AkxThBmYpggzcNVCJqxIRQwiLpNBxxqUt/NvuCqmb2Poa+RftCr7DO3te16HBjzbulL22daVsnsAqKIFwMXVzbCLYdVe9vGovzx9xP7469mk3L05d1+qjyKuPAY8397G2PPtbYztAWDVQgCH09MwTTG+Us67nX1fG5G+0o3YvspGtK+yfBmqAExTJDHQaYokBnrrZZEZkqoa3BjFDJlmGA17PF+qE/GbJd3xm0V38qoYT/aLuTzh6w/ST/j6g/QHYBVgKYHTxcVqGKY5DOM4DNNRO3OXkM0JmAto6AE01xBa5OYaQou8B4BmRssAUNQ0TfP169fv169fvz6XSIZhGIbJixcvXrzIFP7+/3/9evc/wyMAVFM8EEOvpngghr5by8hIsqiqBjXGXx0T4zCdTCfj8PJl1fy83vv7q1fHvEubn5+fnwc84etOrp/wdSfXewBUsRDA5upqMU1DNl+/GNunkTDUGrWzn0BDIC5UUw7CwKspB2HgVzVFSFZ1R9QxU8MkHXvLGV8jKxtjv6J9G0N/MX1fIysbQzTdOlK26daRsnsAWLUGWFxcTQum8Skv93j2KLpfjSeb3fvFmM3xt3L3/mwCPN/2Rvb5tjeyewBULQGmzdM0DMzS3vEVHVu6MVTZGNn3Fe37WjxU2RjqAUxThJGfpggjv1uLDAlVdeOIGNH/1P9Q5/Jxvf49nmyOj74quveLufGb4zzh685unvB1Zzd7AFQAWAhguLpaTFNk8/1i7Ni+Oq5BxQVcGABEVcgFXo+qkAu8vlurZiaoqiNi3N2Z94sXL168ePEiR4wYMWLEiBEjRowYMWLEiBEjAFRVtGm4qqJNw7ceGRkZrGpQNW58OozDOIzDy5dV8/Pz8/Pz8/Pz8/Pz8/Pz8/NlPN/rDr6f73UH33sAVLGUwHRxsxqGaq72+tcvy5LsLLZ5JdBo0BdUU7Qgr6ZoQb4NqKon4PH6zfFknHYYjOqLT9XaWdkYWvQr2vcV7fuK9n3F9AEs3SZSduk2kbJ7AKhqBeDm7maYaujzKS8/0f/UJ/eL7v2ie7/o3rfHk83xBDzdZlLu6TaTcnsAWLUAYHcz1KqivUt7V/ZQZWPoX7TvK9r3a6iyMVSJ6QNMUaSQnaJIIXvrGSkSVTWIihsZpsmYjKJ/8vTxvC6694sxm+PJ5vhbuXu/ADzf6w5+nu91Bz97AFi1lACHm9UwVHPztbbpkiKHJVsy2SAcDURTFhZc0ZSFBdeqNqiKQXwej8dxXrx48eLFixcvXrx4oY3g8/////////+voo3IF3cCRE/xjoLoKd5RsPUCKVN9jt/v8TruMJ1MJ9PJ6E3z8y9fvnz58uXLly+rSp+Z+V+9ejXv7+8eukl9XpcPJED4YJP6vC4fSIDwgWN7vdDrmfT//4PHDfg98ns9/qDHnBxps2RPkuw5ciYZOXPJmSFrllSSNVumJDNLphgno2E6GQ3jUBmPeOn/KP11zY6bfxvfjCu/TSuv/Datustxs0/Njpt9anbc7Nv4yiu/TSuv/Datustxs0/Njpt9aptx82/jm175bVp55bfZ/e5y3OxT24ybfWqbcfNv08orv00rr/w27dfsuNmnthk3+7SVV36bVl75bVqJnUxPzXazT0294mnq2W+TikmmE5LiQb3pAa94mnpFAGxeSf1/jn9mWTgDBjhUUv+f459ZFs6AAQ4AAAAAAIAH/0EYBHEAB6gDzBkAAUxWjEAQk7nWaBZuuKvBN6iqkoMah7sAhnRZ6lFjmllwEgGCAde2zYBzAB5AAH5J/X+Of81ycQZMHI0uqf/P8a9ZLs6AiaMRAAAAAAIAOPgPw0EUEIddhEaDphAAjAhrrgAUlNDwPZKFEPFz2JKV4FqHl6tIxjaQDfQAiJqgZk1GDQgcBuAAfkn9f45/zXLiDBgwuqT+P8e/ZjlxBgwYAQAAAAAAg/8fDBlCDUeGDICqAJAT585AAALkhkHxIHMR3AF8IwmgWZwQhv0DcpcIMeTjToEGKDQAB0CEACgAfkn9f45/LXLiDCiMxpfU/+f41yInzoDCaAwAAAAEg4P/wyANDgAEhDsAujhQcBgAHEakAKBZjwHgANMYAkIDo+L8wDUrrgHpWnPwBBoJGZqDBmBAUAB1QANeOf1/zn53uYQA9ckctMrp/3P2u8slBKhP5qABAAAAAACAIAyCIAiD8DAMwoADzgECAA0wQFMAiMtgo6AATVGAE0gADAQA"&gt;&lt;/audio&gt;<br/>
    &lt;audio id="offline-sound-reached" src="data:audio/mpeg;base64,T2dnUwACAAAAAAAAAAA/aj8KAAAAAAKIghABHgF2b3JiaXMAAAAAAkSsAAAAAAAAAHECAAAAAAC4AU9nZ1MAAAAAAAAAAAAAP2o/CgEAAABF7zgqEkT/////////////////////kQN2b3JiaXM0AAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAyMDA3MDQgKFJlZHVjaW5nIEVudmlyb25tZW50KQAAAAABBXZvcmJpcylCQ1YBAAgAAAAxTCDFgNCQVQAAEAAAYCQpDpNmSSmllKEoeZiUSEkppZTFMImYlInFGGOMMcYYY4wxxhhjjCA0ZBUAAAQAgCgJjqPmSWrOOWcYJ45yoDlpTjinIAeKUeA5CcL1JmNuprSma27OKSUIDVkFAAACAEBIIYUUUkghhRRiiCGGGGKIIYcccsghp5xyCiqooIIKMsggg0wy6aSTTjrpqKOOOuootNBCCy200kpMMdVWY669Bl18c84555xzzjnnnHPOCUJDVgEAIAAABEIGGWQQQgghhRRSiCmmmHIKMsiA0JBVAAAgAIAAAAAAR5EUSbEUy7EczdEkT/IsURM10TNFU1RNVVVVVXVdV3Zl13Z113Z9WZiFW7h9WbiFW9iFXfeFYRiGYRiGYRiGYfh93/d93/d9IDRkFQAgAQCgIzmW4ymiIhqi4jmiA4SGrAIAZAAABAAgCZIiKZKjSaZmaq5pm7Zoq7Zty7Isy7IMhIasAgAAAQAEAAAAAACgaZqmaZqmaZqmaZqmaZqmaZqmaZpmWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWUBoyCoAQAIAQMdxHMdxJEVSJMdyLAcIDVkFAMgAAAgAQFIsxXI0R3M0x3M8x3M8R3REyZRMzfRMDwgNWQUAAAIACAAAAAAAQDEcxXEcydEkT1It03I1V3M913NN13VdV1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWB0JBVAAAEAAAhnWaWaoAIM5BhIDRkFQCAAAAAGKEIQwwIDVkFAAAEAACIoeQgmtCa8805DprloKkUm9PBiVSbJ7mpmJtzzjnnnGzOGeOcc84pypnFoJnQmnPOSQyapaCZ0JpzznkSmwetqdKac84Z55wOxhlhnHPOadKaB6nZWJtzzlnQmuaouRSbc86JlJsntblUm3POOeecc84555xzzqlenM7BOeGcc86J2ptruQldnHPO+WSc7s0J4ZxzzjnnnHPOOeecc84JQkNWAQBAAAAEYdgYxp2CIH2OBmIUIaYhkx50jw6ToDHIKaQejY5GSqmDUFIZJ6V0gtCQVQAAIAAAhBBSSCGFFFJIIYUUUkghhhhiiCGnnHIKKqikkooqyiizzDLLLLPMMsusw84667DDEEMMMbTSSiw11VZjjbXmnnOuOUhrpbXWWiullFJKKaUgNGQVAAACAEAgZJBBBhmFFFJIIYaYcsopp6CCCggNWQUAAAIACAAAAPAkzxEd0REd0REd0REd0REdz/EcURIlURIl0TItUzM9VVRVV3ZtWZd127eFXdh139d939eNXxeGZVmWZVmWZVmWZVmWZVmWZQlCQ1YBACAAAABCCCGEFFJIIYWUYowxx5yDTkIJgdCQVQAAIACAAAAAAEdxFMeRHMmRJEuyJE3SLM3yNE/zNNETRVE0TVMVXdEVddMWZVM2XdM1ZdNVZdV2Zdm2ZVu3fVm2fd/3fd/3fd/3fd/3fd/XdSA0ZBUAIAEAoCM5kiIpkiI5juNIkgSEhqwCAGQAAAQAoCiO4jiOI0mSJFmSJnmWZ4maqZme6amiCoSGrAIAAAEABAAAAAAAoGiKp5iKp4iK54iOKImWaYmaqrmibMqu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67pAaMgqAEACAEBHciRHciRFUiRFciQHCA1ZBQDIAAAIAMAxHENSJMeyLE3zNE/zNNETPdEzPVV0RRcIDVkFAAACAAgAAAAAAMCQDEuxHM3RJFFSLdVSNdVSLVVUPVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdU0TdM0gdCQlQAAGQAA5KSm1HoOEmKQOYlBaAhJxBzFXDrpnKNcjIeQI0ZJ7SFTzBAEtZjQSYUU1OJaah1zVIuNrWRIQS22xlIh5agHQkNWCAChGQAOxwEcTQMcSwMAAAAAAAAASdMATRQBzRMBAAAAAAAAwNE0QBM9QBNFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcTQM0UQQ0UQQAAAAAAAAATRQB0VQB0TQBAAAAAAAAQBNFwDNFQDRVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcTQM0UQQ0UQQAAAAAAAAATRQBUTUBTzQBAAAAAAAAQBNFQDRNQFRNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQ4AAAEWQqEhKwKAOAEAh+NAkiBJ8DSAY1nwPHgaTBPgWBY8D5oH0wQAAAAAAAAAAABA8jR4HjwPpgmQNA+eB8+DaQIAAAAAAAAAAAAgeR48D54H0wRIngfPg+fBNAEAAAAAAAAAAADwTBOmCdGEagI804RpwjRhqgAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAQcAgAATykChISsCgDgBAIejSBIAADiSZFkAAKBIkmUBAIBlWZ4HAACSZXkeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAIABBwCAABPKQKEhKwGAKAAAh6JYFnAcywKOY1lAkiwLYFkATQN4GkAUAYAAAIACBwCAABs0JRYHKDRkJQAQBQDgcBTL0jRR5DiWpWmiyHEsS9NEkWVpmqaJIjRL00QRnud5pgnP8zzThCiKomkCUTRNAQAABQ4AAAE2aEosDlBoyEoAICQAwOE4luV5oiiKpmmaqspxLMvzRFEUTVNVXZfjWJbniaIomqaqui7L0jTPE0VRNE1VdV1omueJoiiapqq6LjRNFE3TNFVVVV0XmuaJpmmaqqqqrgvPE0XTNE1VdV3XBaJomqapqq7rukAUTdM0VdV1XReIomiapqq6rusC0zRNVVVd15VlgGmqqqq6riwDVFVVXdeVZRmgqqrquq4rywDXdV3ZlWVZBuC6rivLsiwAAODAAQAgwAg6yaiyCBtNuPAAFBqyIgCIAgAAjGFKMaUMYxJCCqFhTEJIIWRSUioppQpCKiWVUkFIpaRSMkotpZZSBSGVkkqpIKRSUikFAIAdOACAHVgIhYasBADyAAAIY5RizDnnJEJKMeaccxIhpRhzzjmpFGPOOeeclJIx55xzTkrJmHPOOSelZMw555yTUjrnnHMOSimldM4556SUUkLonHNSSimdc845AQBABQ4AAAE2imxOMBJUaMhKACAVAMDgOJalaZ4niqZpSZKmeZ4nmqZpapKkaZ4niqZpmjzP80RRFE1TVXme54miKJqmqnJdURRN0zRNVSXLoiiKpqmqqgrTNE3TVFVVhWmapmmqquvCtlVVVV3XdWHbqqqqruu6wHVd13VlGbiu67quLAsAAE9wAAAqsGF1hJOiscBCQ1YCABkAAIQxCCmEEFIGIaQQQkgphZAAAIABBwCAABPKQKEhKwGAcAAAgBCMMcYYY4wxNoxhjDHGGGOMMXEKY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHG2FprrbVWABjOhQNAWYSNM6wknRWOBhcashIACAkAAIxBiDHoJJSSSkoVQow5KCWVllqKrUKIMQilpNRabDEWzzkHoaSUWooptuI556Sk1FqMMcZaXAshpZRaiy22GJtsIaSUUmsxxlpjM0q1lFqLMcYYayxKuZRSa7HFGGuNRSibW2sxxlprrTUp5XNLsdVaY6y1JqOMkjHGWmustdYilFIyxhRTrLXWmoQwxvcYY6wx51qTEsL4HlMtsdVaa1JKKSNkjanGWnNOSglljI0t1ZRzzgUAQD04AEAlGEEnGVUWYaMJFx6AQkNWAgC5AQAIQkoxxphzzjnnnHMOUqQYc8w55yCEEEIIIaQIMcaYc85BCCGEEEJIGWPMOecghBBCCKGEklLKmHPOQQghhFJKKSWl1DnnIIQQQiillFJKSqlzzkEIIYRSSimllJRSCCGEEEIIpZRSSikppZRCCCGEEkoppZRSUkophRBCCKWUUkoppaSUUgohhBBKKaWUUkpJKaUUQgmllFJKKaWUklJKKaUQSimllFJKKSWllFJKpZRSSimllFJKSimllEoppZRSSimllJRSSimVUkoppZRSSikppZRSSqmUUkoppZRSUkoppZRSKaWUUkoppaSUUkoppVJKKaWUUkpJKaWUUkqllFJKKaWUklJKKaWUUiqllFJKKaUAAKADBwCAACMqLcROM648AkcUMkxAhYasBADIAAAQB7G01lqrjHLKSUmtQ0Ya5qCk2EkHIbVYS2UgQcpJSp2CCCkGqYWMKqWYk5ZCy5hSDGIrMXSMMUc55VRCxxgAAACCAAADETITCBRAgYEMADhASJACAAoLDB3DRUBALiGjwKBwTDgnnTYAAEGIzBCJiMUgMaEaKCqmA4DFBYZ8AMjQ2Ei7uIAuA1zQxV0HQghCEIJYHEABCTg44YYn3vCEG5ygU1TqQAAAAAAAHgDgAQAg2QAiIqKZ4+jw+AAJERkhKTE5QREAAAAAADsA+AAASFKAiIho5jg6PD5AQkRGSEpMTlACAAABBAAAAABAAAEICAgAAAAAAAQAAAAICE9nZ1MAAMBBAAAAAAAAP2o/CgIAAAB13bfaGzQkISAjIjlF9ab/TP+C/zDj2t/S3MzY6ffohfwM7ZANYCZguPJnaIdsADMBw5XJoQ0ZOcYYAMPeUOzF6FOLFn8s+5wLzgULZWGnL37PEh/kFG/ODSDDAXOKN+cGkOGA5BhjjAEg0CUkX0ruRCoHx5qZ2QfcBG/OBSBAuwnenAtAgIYxxhgDMLDsb5qnIN/pYylmUhTcGO/WBSDD/MZ4ty4AGeYQGGOEAMAnnRbsaj0WOn1tAdwMb9YBkMG7Gd6sAyCDhzHGGAOA99Hgu2o7Hj9ePyvTRsEA3Bir9LPrIgbqhDfGKv3suoiBOiFCAJCRAcAEOF+x5V6TPVQSaWsE0MFUEmlrBNDB9FstyMkxxgDYI6aNganVqhZFUYrdO25k906FtN4rfW+70nfPSv+7Gf5dAWwiNS4Nl0gmAyc6pCG6idS4NFwimQyc6JCG6JlRW4U8cjIyAIxVjIJhoYCNlgqgQzFgowqCDgzoFAE0NpRCNZfwMTwIApqmZMNzvJ/Lilu/XXb/QF0V+cE7TcmG53g/lxW3frvs/oG6KvKD9zMyqjW1NbU11Uq1UgUA2BaOWRCFbYHFbQAAhIWFgQRhQdwJC+JOmHAqYYIwEgYQRgAAADFGBWNRrIkMkZo1AADTUIvYiIqKioqKaagapmEaKoCoCQCAooYBgKSEpDRpPCkeR1iSx+XweVatWbVi1YpVC0sLSwsV01AVVSxWtGJRFZXPnz97j6fkKgBDCSUsIyjJ8hlBhiX0swAACDYJAACAYMW6AgAAoDYIAAAAajMAAACINRMAAACrGgAAAASdAAAAIDoAAFgJAPEBwA4AXqfsQxsTwO8QfT4hwoeXf15JkxMjv5766pR9aGMC+B2izydE+PDyzytpcmLk11PfQgAAWBhMgggBALAw0AZhQdwJGwZwKgEII2EAYSQASRhAAgAAaCYAAFE1rQoAQAEAAPZ2BgIAAGCaCAAAgJhYUxPAgoEkkRIRogAAAAA4PBFBHgAAAFRstAoAACDYZAIAAIC1AgDkATgAgCcAgAbwA6sAQAO8AZ6XjDYpAE2zbA8rYd/1ZRZ8zEtGmxSAplm2h5Ww7/oyCz4uBACwidsAAMQNoE7WAmLidgAAogEAYHEbAAARAgCIHSNAJUtARICok4Bg4TABEQCoDUAuDEgIGyYhjwEANQmERS4cJAAAgNRGAACtABEUQcUqIAC0AAAoAEAFAGgCqiogGCsqoICqqrGIqAAACvb2FkFEEBERrBpARQEAxNZWFAVQUUDsbAEFAMUYawwAgAiqtjYgiAFqKmIIYmHNYFgujwoxogIsYQmhXFOsGaZ1q4YNVtSqVQwLBVVrEVRVtYgAABQsFWLEKSWEfILz/5ZfJ4JGIQD8u3ICgEKEsKICYAio0+sTDWAIoQBhpInxWQ5AyL9tAceyQxlKAZayUhwCQmhbAAAAUHExjiBAadwISQBYlREAbQHlaYELrC4GACjYaIMtAHEACgCepgwGGUvmnbWXEv2mb2l5maYMBhlL5p21lxL9pm9peXmUSAAAeBJlWVNJElhYbBs3ECDBD0wfIqNOAQBhQw9EBEBRp0gLhwCRxwCVeiIDYOHQxgUmkjyYXgJhEQVmcwFhLQybIO4XsEke6AMSAIBhtdojFlU7tRdDgGgGAKsGETFisEZVUEVs7ERFVUUMVBQxEVtROwQVVLCIBUEVUcEEDBuLRdUwxYqxYg0YVABEVDFMq4GgCCqAFWMNaoyogYnaYq8gqIg1Vq1FxSIKqAiojdiqiqigAqghJnamnQFqWm1sDFQAEBBARU17Qy0iqjam1WKoigIAAIiqxd7eYoiahp2tvaEAIDw+n8MTkJQSkWIpSzlcRYuiKqJVUBUbhFgVfwue5HEhZ3PB+1EBgAECatWaLWwpiphZeKgaCoiNFlbURPgPgKiKCLa0CQUFQBALW1oICgUooohimNYtBEUAAEDEms0GhgAgqqg1tRQBVQAVVRusKzAGICAoljapCpoAHuf0JBKAsuvT/FWlFL2b/xsp8zHO6UkkAGXXp/mrSil6N/83UubjAduDuB0AIJW4HQCAxS0AAMIkQgAAwkhwTAAAwihuAwBgIpLqrQMAMRECAJAExwCiTgYALxxoJUkUkQAAgL1Y1NZig2GxmAaA2rIAAIAoQCkJAACKCqKZAABAE2CstRgFAABAAQRjjAUAAAAAMcQwBMBqNQAAAMQUUVEVUdMGniDlExFxUBAAwKpkLp0xIEbRqQBieR0cJQAAgHJYjqQQX4AC2V+t4ARGmeRyoUE44pThgFAAAMCKioKqQatBFQAAYQkYSIqKgK01lVcTYK2AIF9AnE8pQAAA3HGVGQBAuAwgzIgA0PssCwBg+HqjACCfUAEAAAAKSXHCKJeHrT7erCHhYAHbBcAAXuccr6SAXzBA67ahjODDf63fss45XkkBv2CA1m1DGcGH/1q/JZHHhAAAxwQAABECAIAIAQCAYwIAEIjbAACYCAEASCIEACAJjgHUlgEACwO0kYTNAAAAUNsRAADQKAlKTQAAoA2QWQAAgBJASQAAQAUUwagIAAAAAGLY2QkghsVqAADApompagXTBhFLDDWFxwrzeBzCUhAAAAAAoESISBIJBmC44gI8LgAAAAAAAABJQSEJSQLCgkNZDgAAAGAAAAAgApJSIoTTAggA3gCHoWBZAAAAdwkAAACglFACLihACQA+1+wXUvAGc1XPgZizD39LH8ZzzX4hBW8wV/UciDn78Lf0YSyuY0IAgGMCAIAIAQBABACot1IPwDEBAAjEbQAAJBECAIAIAKCoA0mwMPQAwTECQNYGkrAAAIA2AgAAWkigDQAAAFBBVQQaAABAZAVqAAAAAKKqakDUMGwVAAAAALBirAIgN7YwTLGGVQsLMTEwYSDJiAoylKUEAAAAIKAQYRlpDCWANHFhEUkAAAAAQjxBaRwAAAAAAQAAAFBJHgNWAQEIuFRMnCEUAAAIACQgFBAAwLpNNgAAAB7X7FtSwDdowHpsSDH78N9KbzCOa/YtKeAbNGA9NqSYffhvpTcYi+uYEADgmAAAIEIAABAhAAABwTEBAAiOCQBAQIQAACQRAEC1FpLgGEDWAYBgYYBIEDYLAABAaScDAABKE6gZAABAA4iaAAAgswAFAAAAoICxgKg1BgAAAABArXYKqFVtFAAACPSBqoo1NW20MBBREw4RJoISlLCUAAAAAAQAjysgJs4FWApCKAAAAAAAAAAhISFJAQoIkACuOLgsBQAAAAwAAACgEhwGHEBAOBAUZykBAABGIQBQQAE+1xyvvOAL5nq7bQgx+vB/ZaeO5prjlRd8wVxvtw0hRh/+r+zU0TwmAADBMQEAQIQAACACANSprQtwTAAAgmMCAIAISPUGACACAKgpEoljAFkLAI4BAGQNIGwWAACAFm3PAAAArUA2AgAAAEQxRhWZBQAAKAkYrBUAAAAAQLDGGAAwFgAAAAAQY8UAaiO2CgAAAAgooMEaVBFbi6JFERUiICzOE+ATlhIAAJwCAADCMlwRHoQBVkAS4gIAAAAAWIYRpIQAAAAgAAAAQHkCwpTQAAD+xuxbTsA3aMB6XAiiD/+t3I3Gb8y+5QR8gwasx4Ug+vDfyt1o7OiYAAA4JgAAiBAAAEQIAAAcEwCAQNwGAEASIQAASQQAUJuBJFgYWgALA/SDJGwGAACAFi1nAABANoFoJAAA0AygAQAAaAIKAAAAwGKxgGBjtRcAAAAAUAzDXgFs1B4AAAB8ZSuqWLSiES0iWpUICXIIR5JDKQAAAACAUC4rKSHGByBARSSEAAAAAAAAACosyZUmSAAhDivJowQAAAAGAAAAKggpHiUKJADgUFHCggAAgAAUAE4B/rYct7zgC/p6PLbEmH34vzLm8dty3PKCL+jr8dgSY/bh/8qYx46OCQCAYwIAgAgBAEAEAKhbpw7AMQEAcEwAAJIISPUmACQRAEBNJhAsDG2AhQF6SMJmAAAAaKmlBAAAzQxQJAAAAKhB1AiiJgAAUAIwAqIAAAAAIKgxgKJWGwEAAAAA1B5bBcSKRQAAACB+sapa0aoaxRZFVRkRYSkukSKUAgAAAAAIhCkLYQowkBIWBAUAAAD4wqwwlwUAAAAAAAB4woRPGAJQAEYB/rYct5yAX9DA+nOklN6H/xq5Rz68LcctJ+AXNLD+HCml9+G/Ru6RD/kxAQBwTAAAECEAAIgQAIAAxwQAwDEBAEAEhDoFACBsoA04BhBVAHAMACAqkIQFAADa1iIBAEAzAkQTAACIRoLMAgAAZAWsNdaKAAAAAKDYmoYAilULAAAAAIg1VgAABBURnTYsMC0sTFuKoSqCJaS4UtIERQhLAQAAAFAAggxPQhoDEEFhIUFBAAAAAAAAACKSYkICFAyAJSyfEgAAAAAAAICVYsVAFQCw0WabFAAAnqYslRR8Aa/PTwxSWXzor/W8SFOWSgq+gNfnJwapLD7013pe7OI2AADiYwIAEBANAACIEACAxDEBAAjEbQAAIAKoWwIAwgZ6gIVhABYGyCCJANQCAAAA2hYJAACyAdRmAACAUivQAAAAKKDWGEQBAAAAQMA0FcDGxhQAAAAAUAyxBUWNsRYBAAARAUurVk3Dii2sGKZ1S+smhoWIWqpypLiSVJBwOAxlKQioOQUAaJyEgFIKQliGL8njUeAGTZQrKCFCuQAoAAAAAFAKLp8V4rMrAECI4YtzAAAAACgAAAAIlSYuDE4AkABeFWScyntxvYTfb++5+DcnlfuBk10VZJzKe3G9hN9v77n4NyeV+4GTfWF72iluBwBwWDjo9bC4ibJSW0kAQDQAACTBwmgnwMLB9gJEgrAAEgtAmAAAAGJaxM60WAw7WztDZMkAADUUsVpMtbXaiI1aY9QoxooCAEBGLUktNmrYoKIAAAAqio3Y2KqtWLXBqiFWrVk1xNKKpSGCknxRSVHKF+ITwjIs+e7ktlyVTPhOsgHgcoF95bMAQfZq3JoiKKGEUobPYUQkIAyRbwDA3aAANMW0ZrNNpmmYAgAAAKBWbLTJqrH5QQAAALFqg83WTAGwGEWrsQAAnhVcdsc92rfzU+7a+fbf/n4usoLL7rhH+3Z+yl073/7b388F0YJpt53uMIlzgkkYCUvcCYgJiEkCkoAwEjAIAwAACCqK2tmr1c5WrQCrUpqGqlqz0YpVm2y2wbqIxnVbflVuc+sqUebs8CcAYlEVg2gVg8WKAUWrWLBkvwCApVtVsWJFVVRF1WhRVMPSio02mIIKogCcHwAArFHRqFZQFSuqDp2KqrFW4SkAAAAQTDGsW1FDLS2s2mDV0pqlqGFpwHx4ItGstXYAcBuAjRBlPcq8QIHNz7JVAfhcq8DXAXxgvXaeAABHCd5l/PesX0oBA+gy/nvWL6WAARAQRnZgZiZJZmYxZhZjZiYAAADmQ5Sr5AkQFLCayi+VX9I1TAbmByNNiSeS1bA91yGSJZjBmlkFH4VSKSYhNYCisFYPEGXRAFCBQADnc+KhhWWqTPuss82khR7DMuB4+7K9TqgDs4C14pkwBWgDCQfogQBPZ2dTAARAYwAAAAAAAD9qPwoDAAAAhGPUKwlydHJzdnN2RwHeZfz3rF9KAAPoMv571i8lgAEABATMTDIzMwEzMzMzAQkAAIMN74C9AzhKGRBS7Ug48EBTICUcuNgBDPAQiACGUKRJ0aUPnmgPffzWKD/b8ixcFTu3baoOQw/5xt9s7o1o/Xb70VkwgpdI2mIECmilAgDeZfz3rF9KAQPoMv571i+lgAEABATMzMzMzMxMTMzMBCQAADByCtBgSUq3it78CCrhA0UFoIeSDA4p6pIYfSZUYUgAHHvDlB6k3y4BWd77fiwQQP0skkizy/dvD85t6GfLbicQh4LNkIrLFqYv6oCCQoE1BN5l/PesX0oBA+gy/nvWL6WAAQBgZiZgZmZmB2ZmZiYAAADG4BqADH8QJkrth0yGt+Zk2RIlJUAdYwaWjgCgYRAgDA2ESqRKyhJQUhgb8wFKwJCYdqTegu9VnZeJzEj2/salg1Ap6VMwQQHJAINzuwi0AN5l/PesX0oBE+gy/nvWL6WACQBgZgYzMzMzMzMzEwAAEOIFSKQdgGXkaSMZvFpYdPwHjJZg9kCCFKQsLAHkRAYloQBOIJikemyCSj/1yts5b8fX1uk6U8pAP7c1O11NgAY4PD+SuR1ElMkJhsPmGQE7oADeZfzvrF9KARPoMv531i+lgAkABMzMTDKTzMzEzMzMDAAACKc3Pw5SOFxzEnD2mgWgrjk2UBg6dilASmgANweByBmJwwkYTBIPWAttTNqhv3Uy8j7xBXoR4IHyz/Jf1xJZs+kGbrs4KTWNC0iJFCzZDtSuEgAJ3mX896xfSgET6DL+e9YvpYAJACCZmZmZmZlZjJmZSQAAgCNVkW6pBGQRjNBQ59BTYBIkoCkkJqBTQoOXA5L8hUrOljeJgTEN5EBTxuO0bfHde2jix+2aejY+YkOx0uQF/Kz6RBo9AQT8YAQsp/BjAb4iAN5l/PesX0oBG+gy/nvWL6WADQAEBMzMzMzMzGLMzMwMAMDB2RACzHB4MV8gA+Ug3owUUGVKYsA3KOhgwH4gHqBIUPlJGAiB1z9VZYB5rNlcXmDhIP5Ku1+qt60Kb2baYbE7u7IWTSczWp/EG1geirEAIBKkMgDeZfz3LF+aAG6gy/jvWb40AdwAAAYBAQEAApAEzMzMBAAAABQoAJcMgFHAACfgZB28r9ZKUKDQ1ze5X+SCM8AAoOANKk0IAw4="&gt;&lt;/audio&gt;<br/>
   &lt;/template&gt;<br/>
  &lt;/div&gt;<br/>
  &lt;script&gt;var loadTimeDataRaw = {"details":"Detalles","errorCode":"ERR_CONNECTION_TIMED_OUT","fontfamily":"'Segoe UI', Tahoma, sans-serif","fontfamilyMd":"'Segoe UI', Tahoma, sans-serif","fontsize":"75%","heading":{"msg":"No se puede acceder a este sitio"},"hideDetails":"Ocultar detalles","iconClass":"icon-generic","language":"es","reloadButton":{"msg":"Volver a cargar","reloadUrl":"https://10.203.114.11/oc/bes/sm/login/login-colombia.html"},"suggestionsDetails":[{"body":"Revisa los cables y reinicia los routers, mdems u otros dispositivos\n        de red que ests usando.","header":"Comprueba tu conexin a Internet."},{"body":"Si ya est incluido como un programa con permiso para acceder a la red, intenta\n      quitarlo de la lista y agregarlo de nuevo.","header":"Permite que Chrome acceda a la red en tu configuracin de firewall\n          o antivirus."},{"body":"Accede\n          al men de Chrome &gt;\n          \u003Cspan&gt;Configuracin\u003C/span&gt;\n          &gt;\n          \u003Cspan&gt;Mostrar configuracin avanzada\u003C/span&gt;\n          &gt;\n          \u003Cspan&gt;Cambiar la configuracin del proxy\u003C/span&gt;\n          &gt;\n          Configuracin LAN\n          y desmarca la casilla de verificacin \"Usar un servidor proxy para tu LAN\".","header":"Si utilizas un servidor proxy"}],"suggestionsSummaryList":[{"summary":"Comprobar la conexin."},{"summary":"\u003Ca href=\"#buttons\" onclick=\"toggleHelpBox()\"&gt;Comprobar el proxy y el firewall\u003C/a&gt;."},{"summary":"\u003Ca href=\"javascript:diagnoseErrors()\" id=\"diagnose-link\"&gt;Ejecucin del Diagnstico de red de Windows\u003C/a&gt;"}],"suggestionsSummaryListHeader":"Intenta:","summary":{"msg":"\u003Cstrong&gt;10.203.114.11\u003C/strong&gt; tard demasiado en responder."},"textdirection":"ltr","title":"10.203.114.11"};&lt;/script&gt;<br/>
 &lt;/body&gt;<br/>
&lt;/html&gt;</code></pre></div></body></html>